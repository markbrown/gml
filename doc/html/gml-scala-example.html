<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>GML: an extended Scala example
</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<META name="GENERATOR" content="hevea 1.10">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:2ex auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:2ex auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: hevea -o gml-scala-example.html gml-scala-example-hevea.tex -->
<!--PREFIX <ARG >GML: </ARG>-->
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">GML: an extended Scala example</H1><H3 CLASS="titlerest">Mark Brown<BR>
<A HREF="mailto:mark@csse.unimelb.edu.au">mark@csse.unimelb.edu.au</A></H3><H3 CLASS="titlerest">October 2010</H3></TD></TR>
</TABLE><P>
Copyright &#XA9; 2010 Mark Brown.
The text of this work is licensed under a
<a rel="license" href="http://creativecommons.org/licenses/by/3.0/">Creative Commons Attribution 3.0 Unported License</a>.
<a rel="license" href="http://creativecommons.org/licenses/by/3.0/">
<img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by/3.0/80x15.png"/></a>
<br/>
The Scala source code is distributed under a (revised) BSD-style license.
See the file <CODE>LICENSE</CODE> included with the source code.</P><P><BR>
</P><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>&#XA0;&#XA0;Introduction<A NAME="sec:intro"></A></H2><!--SEC END --><!--NAME intro.html-->
<P>This document contains an extended example of programming in Scala.
The program, of which the full listing is supplied,
implements a simple language for ray tracing named GML.
Users write GML code that produces a scene description,
which is then rendered to an output file.
The task originally appeared as a challenge for
the Third Annual ICFP Programming Contest in August, 2000.<SUP><A NAME="text1" HREF="#note1">1</A></SUP></P><P>There are three main parts to our program.
First is a virtual machine that provides
an execution mechanism for the functional language.
We describe the virtual machine in section&#XA0;<A HREF="#sec:vm">3</A>.
The second part is a compiler that reads in GML programs
and produces bytecode suitable for the virtual machine.
We describe the compiler in section&#XA0;<A HREF="#sec:compiling">4</A>.
The last part is a renderer that performs ray tracing on a scene
and produces the output.
This is described in section&#XA0;<A HREF="#sec:rendering">5</A>.</P><P>Our design is by no means the best possible.
Some potential improvements are collected together
in section&#XA0;<A HREF="#sec:exercises">6</A>,
in the form of exercises for the reader.</P><P>This extended example is aimed at &#X201C;advanced&#X201D; readers,
in the sense that we don&#X2019;t take the time to introduce
all the Scala language and library features we use.
Instead, we try to focus our attention on unusual or tricky situations
that can sometimes arise.
We assume the reader has a reasonable understanding of Scala&#X2019;s main features
and is able to consult other documentation if needed.</P><P>Why choose Scala for this task?
The task covers a number of complex and disparate problems,
ranging from program analysis to Boolean algebra and affine geometry.
A high-level language is well suited to these kinds of problems.
In particular,
we&#X2019;ll make use of the &#X201C;functional&#X201D; style
to simplify much of the reasoning we need to do about our program.
Nevertheless, where they are of particular use
we shall still use non-functional language features
such as mutable stacks and maps.
Scala is a good choice for this task because
it provides ready access to the functional style,
without requiring this style to be used throughout the program.</P><P>But why choose this task at all?
Partly because finding solutions to these kinds of problems is interesting;
mostly because the pictures we can produce
are often astounding, and sometimes beautiful!</P><!--BEGIN NOTES section-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes"><TT>http://www.cs.cornell.edu/icfp/</TT>
</DD></DL>
<!--END NOTES-->
<!--TOC section GML-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>&#XA0;&#XA0;GML<A NAME="sec:gml"></A></H2><!--SEC END --><!--NAME gml.html-->
<P>This is a quick introduction to GML.
The complete definition is in section 2 of the task specification,
which can be found on the contest website.
If you already know GML you can skip this part.</P><P>A GML program is a list of terms,
where each term is either a function, an array or a token.
A function is a list of terms surrounded by curly braces,
and an array is a list of terms surrounded by square brackets.
A token is an identifier, a binder (an identifier preceded by &#X2018;<CODE>/</CODE>&#X2019;),
an operator or a literal value
(a Boolean, integer, real or string).</P><P>Evaluation proceeds by stepping through each term in the list,
maintaining an <EM>environment</EM> mapping identifiers to values
and a <EM>data stack</EM> for intermediate results.
An identifier is evaluated by
pushing the value it maps to in the environment onto the data stack.
A binder is evaluated by popping a value off the data stack
and mapping the identifier to that value.
Literals are pushed directly onto the data stack.
The language defines a fixed set of operators
that evaluate by popping inputs then pushing the result.
To evaluate an array,
we first evaluate its list of terms starting with a new data stack.
The final contents of the data stack are converted into an array value,
which is then pushed onto the original stack.</P><P>To evaluate a function we just
push a value representing the function onto the stack.
We don&#X2019;t evaluate the terms inside the function until later
when we reach one of two important operators, <CODE>apply</CODE> and <CODE>if</CODE>.
The <CODE>apply</CODE> operator saves the current environment,
then pops a function value off the stack and evaluates it.
When the evaluation finishes, the saved environment is restored.
The <CODE>if</CODE> operator is similar except that it pops three values:
a Boolean and two functions.
If the Boolean is <CODE>true</CODE> it evaluates the first function,
otherwise it evaluates the second.</P><P>Scene construction and rendering,
which is the main purpose of a GML program,
is all done via built-in operators.
Since the implementation of these operators is somewhat orthogonal
to the virtual machine and compiler,
we leave further discussion of them to section&#XA0;<A HREF="#sec:rendering">5</A>.</P><!--TOC section The virtual machine-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc3">3</A>&#XA0;&#XA0;The virtual machine<A NAME="sec:vm"></A></H2><!--SEC END --><!--NAME vm.html-->
<!--TOC subsection Locals and nonlocals-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">3.1</A>&#XA0;&#XA0;Locals and nonlocals<A NAME="sec:localsvsnonlocals"></A></H3><!--SEC END --><P>Consider the GML expression <CODE>{/x x y}</CODE>.
When this function is pushed onto the data stack
we will not know the value of <CODE>x</CODE>.
That value will only become known after we apply the function,
at which point <CODE>x</CODE> will become bound to the next value on the stack.
In contrast, we will know the value of <CODE>y</CODE>
because GML is lexically scoped;
<CODE>y</CODE> must already be bound in the environment,
and it keeps this value when the function is applied.
This means that the runtime representation of the function
must include a value for <CODE>y</CODE> but not for <CODE>x</CODE>.</P><P>We refer to identifiers like <CODE>x</CODE> as <EM>locals</EM>,
and identifiers like <CODE>y</CODE> as <EM>nonlocals</EM>.
An identifier occurrence in a function is local if
there is a corresponding binder somewhere to its left,
within the same or an enclosing scope.
By &#X201C;scope&#X201D; we mean either the function itself or a nested array.
For example, in <CODE>{/x [x]}</CODE> the identifier is local because
the binder is in an enclosing scope,
but in <CODE>{[/x] x}</CODE> it is nonlocal
because the binder in the inner scope doesn&#X2019;t count.</P><P>The virtual machine uses <EM>closures</EM> to represent functions.
A closure is a code address combined with an array of values,
one for each of the function&#X2019;s nonlocals.
We refer to this array as a <EM>context</EM>.
Space will also be needed to store the values of locals
when the function is applied.
We shall refer to the space allocated for this purpose as a <EM>frame</EM>.
Thus, the environment in our implementation
is split into a context and a frame.</P><P>Figure&#XA0;<A HREF="#fig:value">1</A> shows the runtime representation of values
(more cases will be added later for scene descriptions).
All of the cases here except <CODE>ClosureValue</CODE>
are just wrappers around the corresponding Scala type.
For closure values, the <CODE>address</CODE> parameter
is an index into a bytecode array.
The array will contain all of the bytecode for the entire program;
the closure address value points to the start of the code for that closure.
Our bytecode design is discussed in section&#XA0;<A HREF="#sec:bytecode">3.3</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 1: Runtime values<A NAME="fig:value"></A> (incomplete).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

sealed abstract class Value

case class BoolValue(b: Boolean) extends Value {
  override def toString = b.toString
}

case class IntValue(n: Int) extends Value {
  override def toString = n.toString
}

case class RealValue(d: Double) extends Value {
  override def toString = d.toString
}

case class StringValue(s: String) extends Value {
  override def toString = "\""+ s +"\""
}

case class ArrayValue(elements: Array[Value]) extends Value {
  override def toString = "["+ elements.mkString(", ") +"]"
}

case class ClosureValue(address: Int, context: Array[Value]) extends Value {
  override def toString = "{&amp;"+ address +", "+ context.mkString(", ") +"}"
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>We override to <CODE>toString</CODE> method
so that values print in a way similar to GML terms.
This can&#X2019;t completely be done however,
because there is no GML equivalent of a closure address.
We just print the address as an integer with a &#X201C;<CODE>&amp;</CODE>&#X201D; before it.</P><!--TOC subsection The machine state-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc5">3.2</A>&#XA0;&#XA0;The machine state</H3><!--SEC END --><P>The virtual machine requires three stacks:
the data stack mentioned previously,
a meta-stack and a frame stack.
Along with the machine registers described below,
these stacks comprise the virtual machine state.</P><P>The meta-stack is conceptually a stack of data stacks.
It is used to support array construction.
At the start of an array we push the current data stack onto the meta-stack.
At the end of the array we make the current data stack into an array value
then pop the previous data stack off the meta-stack.</P><P>The frame stack is used to support function calls.
If a function has any locals,
it allocates space for them by pushing a new frame onto the frame stack.
Any function that does this is required to pop the frame before it returns,
so that the caller regains access to its own frame.
We refer to this as entering and leaving the frame, respectively.</P><P>But what happened to the context?
In section&#XA0;<A HREF="#sec:localsvsnonlocals">3.1</A> we said that the environment consists of
a frame <EM>and</EM> a context.
When calling a function we need to save the environment,
which means saving the context as well as the frame.
We do this by storing a pointer to the context in one of the frame slots;
in later sections we&#X2019;ll show how this is achieved.</P><P>Figure&#XA0;<A HREF="#fig:expandarray">2</A> shows some code that will
help us implement the virtual machine stacks.
The <CODE>ExpandArray</CODE> object provides a method to set an array element,
using an immutable style interface where the result array is returned.
In most cases <CODE>set</CODE> behaves just like a mutable update
and returns the same array that is passed to it without copying.
However, if the index is out of range then a larger array is returned.<SUP><A NAME="text2" HREF="#note2">2</A></SUP></P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 2: Support code<A NAME="fig:expandarray"></A> for expanding arrays on demand.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

object ExpandArray {
  // Set the value at the index, resizing if needed.
  def set[T](array: Array[T], index: Int, value: T): Array[T] = {
    val newArray = if (index &gt;= array.length) resize(array, index) else array
    newArray(index) = value
    newArray
  }

  // Double the array size until it includes the index.
  def resize[T](array: Array[T], index: Int): Array[T] = {
    var size = array.length
    if (size == 0) size = 1
    while (size &lt;= index) size *= 2
    val newArray = new Array[T](size)
    array.copyToArray(newArray, 0)
    newArray
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The data stack is implemented in Figure&#XA0;<A HREF="#fig:datastack">3</A>.
It works in an obvious way,
except that we have a separate stack pointer for the bottom of the stack.
We shall use the extra pointer to implement the meta-stack.</P><P>The meta-stack, implemented as part of the same class,
is actually a stack of <CODE>stackBottom</CODE> values.
To start an array the current value of <CODE>stackBottom</CODE> is pushed,
and it is then set to <CODE>stackTop</CODE>.
Since <CODE>stackBottom</CODE> now equals <CODE>stackTop</CODE>,
the data stack is effectively empty.
At the end of the array constructor,
we remove the stack entries between <CODE>stackBottom</CODE> and <CODE>stackTop</CODE>
and copy them to the new array.
We then pop the value of <CODE>stackBottom</CODE> that was earlier pushed,
and push the new array onto the data stack as an <CODE>ArrayValue</CODE>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3: Virtual machine<A NAME="fig:datastack"></A> data stack and meta-stack.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

class DataStack {
  // Data stack.
  var stack = new Array[Value](256)
  var stackTop = 0
  var stackBottom = 0

  def push(value: Value): Unit = {
    stack = ExpandArray.set(stack, stackTop, value)
    stackTop += 1
  }

  def pop: Value = {
    if (stackTop == stackBottom) throw new Exception("gml: stack underflow")
    stackTop -= 1
    stack(stackTop)
  }

  // Meta-stack.
  var metaStack = new Array[Int](8)
  var metaStackTop = 0

  def startArray: Unit = {
    metaStack = ExpandArray.set(metaStack, metaStackTop, stackBottom)
    metaStackTop += 1
    stackBottom = stackTop
  }

  def endArray: Unit = {
    val elements = stack.slice(stackBottom, stackTop)
    stackTop = stackBottom
    if (metaStackTop == 0) throw new Exception("gml: meta stack underflow")
    metaStackTop -= 1
    stackBottom = metaStack(metaStackTop)
    push(ArrayValue(elements))
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Figure&#XA0;<A HREF="#fig:framestack">4</A> shows the frame stack implementation.
The frame pointer points to slot zero of the topmost frame,
or is -1 if there are no frames.
To access a frame slot,
either when getting or setting,
we simply subtract the slot number from the frame pointer.
We use <CODE>apply</CODE> and <CODE>update</CODE> as the access method names,
which in Scala allows the use of syntax which is similar to array access.
For example, we get a slot value with <CODE>frames(slot)</CODE>
and we set it with <CODE>frames(slot) = value</CODE>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 4: Virtual machine<A NAME="fig:framestack"></A> frame stack.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

class Frames {
  var frames = new Array[Value](4096)
  var framePtr = -1

  def enter(size: Int): Unit = {
    framePtr += size
    if (framePtr &gt;= frames.length) frames = ExpandArray.resize(frames, framePtr)
  }

  def leave(size: Int): Unit = {
    framePtr -= size
    if (framePtr &lt; -1) throw new Exception("gml: frame stack underflow")
  }

  def apply(slot: Int): Value =
    frames(framePtr - slot)

  def update(slot: Int, value: Value): Unit =
    frames(framePtr - slot) = value
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Aside from the stacks,
the virtual machine state includes three registers.
The <CODE>currentContext</CODE> register points to
the context of the closure that is currently executing.
The <CODE>codePointer</CODE> register contains
the address of the next bytecode to be executed,
and <CODE>returnPointer</CODE> contains
the address we should return to when the current closure finishes.
A negative value of <CODE>codePointer</CODE>
indicates that the program should halt
(so a negative value of <CODE>returnPointer</CODE> means we should halt
when the current closure finishes).
The <CODE>VM</CODE> class,
which contains the stacks and registers
and will later implement the main loop,
is shown in Figure&#XA0;<A HREF="#fig:vmregisters">5</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 5: The<A NAME="fig:vmregisters"></A> virtual machine.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

class VM(code: Array[Bytecode]) {
  // Stacks.
  val data = new DataStack
  val frames = new Frames

  // Registers.
  var currentContext: Array[Value] = null
  var codePointer = -1
  var returnPointer = -1

  ...
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The paramater to the <CODE>VM</CODE> class is a bytecode array.
Bytecode is described in the next section.</P><!--TOC subsection Bytecode-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc6">3.3</A>&#XA0;&#XA0;Bytecode<A NAME="sec:bytecode"></A></H3><!--SEC END --><P>Bytecode is a way of representing virtual machine instructions
using fixed-size chunks of data.
This section describes the bytecode we use in our program.
Note that we don&#X2019;t actually represent these in byte form,
although it wouldn&#X2019;t be hard to encode them in two words
(or even one)
by using external tables for the operators and
real and string literals.</P><P>Figure&#XA0;<A HREF="#fig:bytecode">6</A> shows the bytecode definition.
We use case classes so we can pattern match on bytecode values,
which will be useful when implementing the main loop of the virtual machine
in section&#XA0;<A HREF="#sec:mainloop">3.5</A>.
Note that the cases with no parameters are actually case objects,
not case classes.
This makes sense because there is only ever one value in each of these cases&#X2014;there are no parameters to distinguish between different occurrences.
For example, every occurrence of <CODE>Return</CODE> is identical
so they are all really the same value.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 6: Bytecode<A NAME="fig:bytecode"></A> definition.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

sealed abstract class Bytecode

case object DoRender extends Bytecode
case class Apply(isTailCall: Boolean) extends Bytecode
case class If(isTailCall: Boolean) extends Bytecode
case object Return extends Bytecode
case class EnterFrame(size: Int) extends Bytecode
case class LeaveFrame(size: Int) extends Bytecode
case class SaveContext(slot: Int) extends Bytecode
case class RestoreContext(slot: Int) extends Bytecode
case class SaveReturnPtr(slot: Int) extends Bytecode
case class RestoreReturnPtr(slot: Int) extends Bytecode
case class MakeClosure(size: Int) extends Bytecode
case class PushInt(n: Int) extends Bytecode
case class PushReal(d: Double) extends Bytecode
case class PushString(s: String) extends Bytecode
case class PushNonlocal(slot: Int) extends Bytecode
case class PushLocal(slot: Int) extends Bytecode
case class PopLocal(slot: Int) extends Bytecode
case object PopUnused extends Bytecode
case class Op(op: Operators.OpType) extends Bytecode
case object StartArray extends Bytecode
case object EndArray extends Bytecode
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The first bytecode, <CODE>DoRender</CODE>,
implements the GML <CODE>render</CODE> operator.</P><P>The next two cases, <CODE>Apply</CODE> and <CODE>If</CODE>,
implement the <CODE>apply</CODE> and <CODE>if</CODE> operators that call a closure.
To perform the call,
we set <CODE>currentContext</CODE> to the closure&#X2019;s context,
set <CODE>returnPointer</CODE> to the current value of <CODE>codePointer</CODE>,
and set <CODE>codePointer</CODE> to the address of the closure.
The <CODE>isTailCall</CODE> parameter is <CODE>true</CODE> if this is a tail call,
which is a call occurring as the last term in a function.
Tail calls are implemented in the same way as regular calls,
except that <CODE>returnPointer</CODE> is left at its current value.
This has the same effect as returning again immediately after the call,
except that there is no need to save and restore <CODE>returnPointer</CODE>.</P><P>The next bytecode, <CODE>Return</CODE>, causes the current closure to return.
We simply set <CODE>codePointer</CODE> to <CODE>returnPointer</CODE>.</P><P><CODE>EnterFrame</CODE> and <CODE>LeaveFrame</CODE> create or destroy a frame
with the given size.
If a function enters a frame it must leave that frame before it returns,
and it must use the same size in both cases.
No frame slots may be accessed
unless a frame of a suitable size has been entered (and not left).</P><P><CODE>SaveContext</CODE> and <CODE>RestoreContext</CODE>
copy the <CODE>currentContext</CODE> register to and from a frame slot,
given by the <CODE>slot</CODE> parameter.
<CODE>SaveReturnPtr</CODE> and <CODE>RestoreReturnPtr</CODE> do the same for the
<CODE>returnPointer</CODE> register.
Making a call destroys the values of these registers;
if the caller needs to refer to either register after the call
then it must save and restore the register to retain the correct value.</P><P><CODE>MakeClosure</CODE> constructs a new closure value.
The <CODE>size</CODE> parameter is equal to the size of the context.
The virtual machine pops this many values to create the context,
then pops the address value before pushing the new closure onto the stack.</P><P><CODE>PushInt</CODE>, <CODE>PushReal</CODE> and <CODE>PushString</CODE>
push literal values onto the stack.
<CODE>PushNonlocal</CODE> and <CODE>PushLocal</CODE> push
a value from the given slot of the context or frame, respectively.</P><P><CODE>PopLocal</CODE> pops a value into the given frame slot.
There is no corresponding bytecode to pop a nonlocal value;
this wouldn&#X2019;t make sense, because
the nonlocals are fixed when the context is created.
<CODE>PopUnused</CODE> pops a value and discards it.</P><P><CODE>Op</CODE> performs the action of an operator.
The <CODE>op</CODE> parameter is a function acting on a data stack,
which has the side effect of performing the operation.
This type is defined in the <CODE>Operators</CODE> object,
shown in Figure&#XA0;<A HREF="#fig:operators">7</A>.
The operator table will be defined in the <CODE>Operators.opTable</CODE> value,
using a map literal.
We provide <CODE>apply</CODE> and <CODE>isDefinedAt</CODE> methods so that
<CODE>Operators</CODE> can be used like a partial function.
We shall fill in the details in section&#XA0;<A HREF="#sec:operators">3.6</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 7: The<A NAME="fig:operators"></A> <TT>Operators</TT> object.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

import Math._

object Operators {
  type OpType = DataStack =&gt; Unit

  def apply(name: String): OpType =
    opTable(name)

  def isDefinedAt(name: String): Boolean =
    opTable contains name

  val opTable: Map[String, OpType] = Map(
    ...
  )
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Note that we don&#X2019;t count
<CODE>render</CODE>, <CODE>apply</CODE> and <CODE>if</CODE> as operators
since they each have their own specialized bytecode.
Conversely,
we count <CODE>true</CODE> and <CODE>false</CODE> as operators
to save us the trouble of dealing with Booleans separately.</P><P>The last two bytecode cases, <CODE>StartArray</CODE> and <CODE>EndArray</CODE>,
implement the start and end of array construction.</P><P>One observation about our bytecode design is worth making.
The simplest possible function in GML is the identity, <CODE>{}</CODE>,
which returns as soon as it is called,
and the next simplest functions are ones that return a constant,
such as <CODE>{ 1 }</CODE> or <CODE>{ x }</CODE>.
In our bytecode,
the identity is implemented as a single <CODE>Return</CODE> bytecode,
and constant functions are implemented as a single <CODE>Push</CODE>
(of the required type) followed by a <CODE>Return</CODE>.
With no more than two instructions,
the implementation of these functions is fast.
This is an example of optimizing the common case:
given that these functions, particularly the constant functions,
are very common in GML,
this goes a long way towards making our program efficient.</P><!--TOC subsection Dynamic type checks-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">3.4</A>&#XA0;&#XA0;Dynamic type checks<A NAME="sec:dynamic"></A></H3><!--SEC END --><P>GML is a dynamically typed language,
but in our code we will need to access runtime values statically.
For example,
to implement a call we will need to pop a closure value off the stack
and access its address and context,
but the value we get from the stack is just a <CODE>Value</CODE>,
not a <CODE>ClosureValue</CODE>.
If the user writes a program such as <CODE>{1 apply}</CODE>
then the value we get won&#X2019;t even be a closure,
it will be an integer.
In this case we need to halt the program and report a type error.</P><P>We will need to implement dynamic type checks to detect these errors
and produce appropriate error messages.
A good place to implement them is in the base class for runtime values.
The implementation of <CODE>Value</CODE> in Figure&#XA0;<A HREF="#fig:basevalue">8</A>
contains methods for either extracting the information in a more usable form
or throwing an exception.
In the latter case we call <CODE>typeError</CODE>,
which has the unusual result type of <CODE>Nothing</CODE>.
Since there are no values with this type,
this precludes the method from ever returning normally
(which it doesn&#X2019;t do because it always throws an exception).
The reason we give it this type is because, in each place it is used,
a different and incompatible result type is expected.
Literally, <CODE>Nothing</CODE> satisfies these expectations.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 8: Base class<A NAME="fig:basevalue"></A> for runtime values.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">sealed abstract class Value {
  def toBoolean: Boolean = this match {
    case BoolValue(b) =&gt; b
    case _ =&gt; typeError("Boolean")
  }

  def toInt: Int = this match {
    case IntValue(n) =&gt; n
    case _ =&gt; typeError("Int")
  }

  def toReal: Double = this match {
    case RealValue(d) =&gt; d
    case _ =&gt; typeError("Real")
  }

  def toStr: String = this match {
    case StringValue(s) =&gt; s
    case _ =&gt; typeError("String")
  }

  def toArray: Array[Value] = this match {
    case ArrayValue(elements) =&gt; elements
    case _ =&gt; typeError("Array")
  }

  def toClosure: ClosureValue = this match {
    case c @ ClosureValue(_, _) =&gt; c
    case _ =&gt; typeError("Function")
  }

  private def typeError(s: String): Nothing =
    throw new Exception("type error: expected "+ s +" found "+ this)
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Notice how we avoided using the name <CODE>toString</CODE>?
If we hadn&#X2019;t,
Scala would complain because this overrides the <CODE>toString</CODE> method
defined in class <CODE>Any</CODE>,
and we haven&#X2019;t used an <CODE>override</CODE> modifier.
This is a good thing because if we did accidentally override that method
the result would be disastrous.
It would be called any time we tried to print out a <CODE>Value</CODE>
or append it to a string, and in most cases,
this would just call <CODE>typeError</CODE>&#X2026; which would
try to append the value to a string for the error message.
The end result would be a stack overflow.</P><!--TOC subsection The main loop-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc8">3.5</A>&#XA0;&#XA0;The main loop<A NAME="sec:mainloop"></A></H3><!--SEC END --><P>Some support methods that use the dynamic type checks
are shown in Figure&#XA0;<A HREF="#fig:vmsupport">9</A>.
These will be called from the main loop to implement
the construction and calling of closures.
Note that, because the data is coming off a stack,
we get the last pieces of data before earlier ones.
So <CODE>callIf</CODE> pops the &#X201C;else&#X201D; value first and the condition last,
which is the opposite order to how they are written in the GML program.
Likewise, the <CODE>for</CODE> loop in <CODE>makeClosure</CODE>
fills in the context array in reverse.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 9: Virtual machine<A NAME="fig:vmsupport"></A> support methods
(<TT>runtime.VM</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def callClosure(value: Value, isTailCall: Boolean): Unit = {
    val closure = value.toClosure
    if (!isTailCall) returnPointer = codePointer
    codePointer = closure.address
    currentContext = closure.context
  }

  private def callIf(isTailCall: Boolean): Unit = {
    val elseVal = data.pop
    val thenVal = data.pop
    val condition = data.pop.toBoolean
    callClosure(if (condition) thenVal else elseVal, isTailCall)
  }

  private def makeClosure(size: Int): Unit = {
    val context = new Array[Value](size)
    for (i &lt;- (0 until size).reverse) context(i) = data.pop
    data.push(ClosureValue(data.pop.toInt, context))
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The main loop of the virtual machine is shown in Figure&#XA0;<A HREF="#fig:mainloop">10</A>.
It first sets up the registers to the desired values,
then evaluates bytecode until <CODE>codePointer</CODE> is negative.
When it returns,
it does not set the registers back to their previous values.
If this is required, the caller will need to arrange it.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 10: Virtual machine<A NAME="fig:mainloop"></A> main loop
(<TT>runtime.VM</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  def execute(address: Int): Unit = {
    codePointer = address
    returnPointer = -1
    while (codePointer &gt;= 0) {
      val bytecode = code(codePointer)
      codePointer += 1
      bytecode match {
        case DoRender               =&gt; render
        case Apply(isTailCall)      =&gt; callClosure(data.pop, isTailCall)
        case If(isTailCall)         =&gt; callIf(isTailCall)
        case Return                 =&gt; codePointer = returnPointer
        case EnterFrame(size)       =&gt; frames.enter(size)
        case LeaveFrame(size)       =&gt; frames.leave(size)
        case SaveContext(slot)      =&gt; frames(slot) = ArrayValue(currentContext)
        case RestoreContext(slot)   =&gt; currentContext = frames(slot).toArray
        case SaveReturnPtr(slot)    =&gt; frames(slot) = IntValue(returnPointer)
        case RestoreReturnPtr(slot) =&gt; returnPointer = frames(slot).toInt
        case MakeClosure(size)      =&gt; makeClosure(size)
        case PushInt(n)             =&gt; data.push(IntValue(n))
        case PushReal(d)            =&gt; data.push(RealValue(d))
        case PushString(s)          =&gt; data.push(StringValue(s))
        case PushNonlocal(slot)     =&gt; data.push(currentContext(slot))
        case PushLocal(slot)        =&gt; data.push(frames(slot))
        case PopLocal(slot)         =&gt; frames(slot) = data.pop
        case PopUnused              =&gt; data.pop
        case Op(op)                 =&gt; op(data)
        case StartArray             =&gt; data.startArray
        case EndArray               =&gt; data.endArray
      }
    }
  }

  private def render: Unit = {
    ...
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The <CODE>render</CODE> method will implement the GML rendering operator.
We shall define this method in section&#XA0;<A HREF="#sec:render">5.11</A>.</P><P>The initial value of &#X2212;1 for <CODE>returnPointer</CODE> is significant.
As we said earlier,
this will cause execution to halt at the end of the current closure.
In particular, the while loop will continue running until
we reach a <CODE>Return</CODE> bytecode.
At that point the &#X2212;1 value is copied to the <CODE>codePointer</CODE> register,
causing the next loop test to fail and the loop to terminate.</P><P>The <CODE>currentContext</CODE> register is not initialized at all.
It is assumed that the code being executed is at the top level
where nonlocals are not allowed,
so this register shouldn&#X2019;t be looked at until after a call.
At this point, the register will be set to
the context of the closure that is called.</P><!--TOC subsection Operators-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc9">3.6</A>&#XA0;&#XA0;Operators<A NAME="sec:operators"></A></H3><!--SEC END --><P>The last thing required for our virtual machine is the operator table.
We&#X2019;ll start with just the computational operators;
the scene building operators will be left until section&#XA0;<A HREF="#sec:rendering">5</A>.</P><P>Figure&#XA0;<A HREF="#fig:lifting">11</A> shows some support methods
in the <CODE>Operators</CODE> object.
These <EM>lifting</EM> methods will help
write the operator definitions concisely.
Each takes a function,
which itself takes one or two arguments
of type <CODE>Double</CODE> or <CODE>Int</CODE>,
and carries this function out on a <CODE>DataStack</CODE>.
That is,
it pops the arguments,
calls the function with these arguments,
then pushes the result.
The letters at the end of the method name indicate
the number and type of arguments expected by the function.
Note once again that,
for the two-argument methods,
the arguments are popped in reverse order.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 11: Operator table<A NAME="fig:lifting"></A> support methods
(<TT>runtime.Operators</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  def liftR(f: Double =&gt; Value)(data: DataStack): Unit =
    data.push(f(data.pop.toReal))

  def liftI(f: Int =&gt; Value)(data: DataStack): Unit =
    data.push(f(data.pop.toInt))

  def liftRR(f: (Double, Double) =&gt; Value)(data: DataStack) = {
    val arg2 = data.pop.toReal
    val arg1 = data.pop.toReal
    data.push(f(arg1, arg2))
  }

  def liftII(f: (Int, Int) =&gt; Value)(data: DataStack): Unit = {
    val arg2 = data.pop.toInt
    val arg1 = data.pop.toInt
    data.push(f(arg1, arg2))
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>We use the curried form of declaration for these methods
because we want to supply the function argument in the operator table,
but we won&#X2019;t supply the <CODE>DataStack</CODE> argument until the operator is used
(this is the <CODE>op(data)</CODE> call in Figure&#XA0;<A HREF="#fig:mainloop">10</A>).</P><P>The computational operators are defined in Figure&#XA0;<A HREF="#fig:optable">12</A>.
Using a map literal gives us a convenient way to write the table,
and will also allow the parser to do fast lookups.
The lifting methods certainly make defining operators much easier,
but it&#X2019;s tempting to try to go further and declare them as <CODE>implicit</CODE>.
Hopefully, we could then omit the methods
and have Scala insert them where needed.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 12: Operator definitions<A NAME="fig:optable"></A>
(<TT>runtime.Operators</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  val opTable: Map[String, OpType] = Map(
    "acos"       -&gt; liftR(x =&gt; RealValue(toDegrees(acos(x)))),
    "addf"       -&gt; liftRR((x, y) =&gt; RealValue(x + y)),
    "addi"       -&gt; liftII((x, y) =&gt; IntValue(x + y)),
    "asin"       -&gt; liftR(x =&gt; RealValue(toDegrees(asin(x)))),
    "clampf"     -&gt; liftR(clamp),
    "cos"        -&gt; liftR(x =&gt; RealValue(cos(toRadians(x)))),
    "divf"       -&gt; liftRR((x, y) =&gt; RealValue(x / y)),
    "divi"       -&gt; liftII((x, y) =&gt; IntValue(x / y)),
    "eqf"        -&gt; liftRR((x, y) =&gt; BoolValue(x == y)),
    "eqi"        -&gt; liftII((x, y) =&gt; BoolValue(x == y)),
    "false"      -&gt; { _ push(BoolValue(false)) },
    "floor"      -&gt; liftR(x =&gt; IntValue(floor(x).toInt)),
    "frac"       -&gt; liftR(frac),
    "get"        -&gt; doGet,
    "length"     -&gt; doLength,
    "lessf"      -&gt; liftRR((x, y) =&gt; BoolValue(x &lt; y)),
    "lessi"      -&gt; liftII((x, y) =&gt; BoolValue(x &lt; y)),
    "modi"       -&gt; liftII((x, y) =&gt; IntValue(x % y)),
    "mulf"       -&gt; liftRR((x, y) =&gt; RealValue(x * y)),
    "muli"       -&gt; liftII((x, y) =&gt; IntValue(x * y)),
    "negf"       -&gt; liftR(x =&gt; RealValue(-x)),
    "negi"       -&gt; liftI(x =&gt; IntValue(-x)),
    "real"       -&gt; liftI(x =&gt; RealValue(x)),
    "sin"        -&gt; liftR(x =&gt; RealValue(sin(toRadians(x)))),
    "sqrt"       -&gt; liftR(x =&gt; RealValue(sqrt(x))),
    "subf"       -&gt; liftRR((x, y) =&gt; RealValue(x - y)),
    "subi"       -&gt; liftII((x, y) =&gt; IntValue(x - y)),
    "true"       -&gt; { _ push(BoolValue(true)) }
  )

  private def clamp(d: Double): Value =
    RealValue(if (d &lt; 0) 0 else if (d &gt; 1) 1 else d)

  private def frac(d: Double): Value =
    RealValue(d - (if (d &lt; 0) ceil(d) else floor(d)))

  private def doGet(data: DataStack): Unit = {
    val i = data.pop.toInt
    val a = data.pop.toArray
    data.push(a(i))
  }

  private def doLength(data: DataStack): Unit =
    data.push(IntValue(data.pop.toArray.length))
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Unfortunately, this doesn&#X2019;t quite work with
Scala&#X2019;s flow-based type inference algorithm.<SUP><A NAME="text3" HREF="#note3">3</A></SUP>
The problem is that if an expression such as
</P><PRE CLASS="verbatim">  x =&gt; RealValue(toDegrees(acos(x)))
</PRE><P>appears where the type <CODE>DataStack =&gt; Unit</CODE> is expected,
Scala not unreasonably guesses that <CODE>x</CODE> has type <CODE>DataStack</CODE>
and <CODE>RealValue(toDegrees(acos(x)))</CODE> has type <CODE>Unit</CODE>.
This causes two things to go wrong.
First, if <CODE>x</CODE> has type <CODE>DataStack</CODE> then
<CODE>acos(x)</CODE> is a type mismatch,
because a <CODE>Double</CODE> is expected.
Second, the body of the function literal
<EM>can</EM> be treated as <CODE>Unit</CODE> by ignoring the result value.
But this doesn&#X2019;t match the type of the implicit method,
which expects an argument of type <CODE>Double =&gt; Value</CODE>,
so the implicit method is not inserted and we get a type mismatch further up.</P><P>The general solution to these kinds of problems
is to add type annotations.
In this case both problems can be avoided
if we add type annotations to the function literals.
For example,
the first three entries in the operator table could be written:
</P><PRE CLASS="verbatim">  "acos" -&gt; ((x =&gt; RealValue(toDegrees(acos(x)))): (Double =&gt; Value)),
  "addf" -&gt; (((x, y) =&gt; RealValue(x + y)): ((Double, Double) =&gt; Value)),
  "addi" -&gt; (((x, y) =&gt; IntValue(x + y)): ((Int, Int) =&gt; Value)),
</PRE><P>This is rather more verbose than explicit lifting,
so the cure is worse than the disease!
Hence, we don&#X2019;t bother with the implicit lifting methods.</P><!--BEGIN NOTES section-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note2" HREF="#text2">2</A></DT><DD CLASS="dd-thefootnotes">This is one place that would need to change for Scala 2.8.
Due to changes in the handling of arrays,
we would need to provide an implicit <TT>ClassManifest</TT> argument
to both of the methods.
However, if we did that the code would no longer compile with Scala 2.7.
See <A HREF="http://www.scala-lang.org/sid/7"><TT>http://www.scala-lang.org/sid/7</TT></A> for more information.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note3" HREF="#text3">3</A></DT><DD CLASS="dd-thefootnotes">This was tested with Scala 2.7.6.
</DD></DL>
<!--END NOTES-->
<!--TOC section Compiling-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc10">4</A>&#XA0;&#XA0;Compiling<A NAME="sec:compiling"></A></H2><!--SEC END --><!--NAME compiling.html-->
<!--TOC subsection Parsing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc11">4.1</A>&#XA0;&#XA0;Parsing<A NAME="sec:parsing"></A></H3><!--SEC END --><P>We shall build a parser for GML using Scala&#X2019;s parsing combinator library,
in package <CODE>scala.util.parsing.combinator</CODE>.
To keep things simple,
we can use the <CODE>StdTokens</CODE> trait
defined in <CODE>scala.util.parsing.syntax</CODE>.
Section&#XA0;<A HREF="#sec:lexer">4.1.1</A> shows how we produce a sequence of GML tokens
by extending <CODE>Lexical</CODE> with <CODE>StdTokens</CODE>.
Section&#XA0;<A HREF="#sec:parsetree">4.1.2</A> describes the parse tree,
and section&#XA0;<A HREF="#sec:parser">4.1.3</A> shows
how it is constructed from a sequence of tokens
by extending <CODE>StdTokenParsers</CODE>.</P><!--TOC subsubsection Lexical analysis-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc12">4.1.1</A>&#XA0;&#XA0;Lexical analysis<A NAME="sec:lexer"></A></H4><!--SEC END --><P><CODE>StdTokens</CODE> in the Scala library defines four types of token:
keywords, numeric literals, string literals, and identifiers.
We&#X2019;ll use keyword tokens to represent graphic characters,
and identifier tokens to represent GML operators and Boolean literals
as well as GML identifiers (the parser will later sort out which of these
are really identifiers, and which are operators).
Numeric and string literal tokens will represent their GML counterparts.</P><P>The start of the <CODE>GmlLexer</CODE> class is shown in Figure&#XA0;<A HREF="#fig:gmllexer">13</A>.
The <CODE>Lexical</CODE> superclass uses trait <CODE>Scanners</CODE>,
which defines abstract methods <CODE>whitespace</CODE> and <CODE>token</CODE>
that we need to implement.
As the name suggests, <CODE>whitespace</CODE> defines a parser for
anything that we wish to regard as whitespace.
Aside from the usual whitespace characters
we also want to treat comments as being equivalent to whitespace,
where a comment consists of &#X2018;<CODE>%</CODE>&#X2019; followed by all characters
up to the next newline or the end of the file
(represented by <CODE>EofCh</CODE>).</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 13: The<A NAME="fig:gmllexer"></A> <TT>GmlLexer</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

import util.parsing.combinator.lexical.Lexical
import util.parsing.syntax.StdTokens

class GmlLexer extends Lexical with StdTokens {
  import util.parsing.input.CharArrayReader.EofCh
  def whitespace: Parser[Any] =
    rep(whitespaceChar | '%' ~ rep(chrExcept('\n', EofCh)))

  def token: Parser[Token] =
    ( name
    | graphic
    | numLiteral
    | stringLiteral
    )

  ...
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The implementation of <CODE>token</CODE> is more involved,
so we&#X2019;ve broken it down into smaller parts.
Note that the parentheses are required around the different options.
Without them, a semi-colon will be inferred after <CODE>name</CODE>,
and Scala will then complain about the code on the next line.</P><P>Token parsers for names, graphic (punctuation) characters
and string literals are shown in Figure&#XA0;<A HREF="#fig:gmllexer2">14</A>.
An important thing to notice in the graphic token parser
is that we can&#X2019;t just write <CODE>('/' | ...)</CODE>,
because Scala would
convert the characters to <CODE>Int</CODE> for the &#X2018;<CODE>|</CODE>&#X2019; operation,
and the resulting <CODE>Int</CODE> does not provide a method for <CODE>^^</CODE>.
But we don&#X2019;t want the version of &#X2018;<CODE>|</CODE>&#X2019; that works on integers,
we want the version that works on parsers!
We can tell Scala this by using an type annotation:
instead of <CODE>'/'</CODE> we write <CODE>('/':Parser[Char])</CODE>.
Hence Scala knows that &#X2018;<CODE>|</CODE>&#X2019; is referring to the parser constructor,
and the resulting parser can be used with <CODE>^^</CODE>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 14: Token parsers<A NAME="fig:gmllexer2"></A> for names,
graphic characters and string literals (<TT>compiler.GmlLexer</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  def name: Parser[Token] =
    letter ~ rep( letter | digit | '-' | '_' ) ^^ {
      case first ~ rest =&gt; Identifier(first::rest mkString "")
    }

  def graphic: Parser[Token] =
    ( ('/': Parser[Char]) | '[' | ']' | '{' | '}' ) ^^
            { c =&gt; Keyword(c toString) }

  def stringLiteral: Parser[Token] =
    ( '\"' ~&gt; rep(chrExcept('\"', EofCh)) &lt;~ '\"' ^^
            { cs =&gt; StringLit(cs mkString "") }
    | '\"' ~&gt; failure("unclosed string literal")
    )
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>String literals where the user has forgotten the closing quote
would not be accepted by the first part of the <CODE>stringLiteral</CODE> rule.
The second part of the rule is included to catch this case and fail,
rather than letting the failure be reported
from an unrelated (and probably baffling) place.</P><P>A numeric literal consists of an integer literal,
an optional fraction part, and an optional exponent.
The token parser is shown in Figure&#XA0;<A HREF="#fig:gmllexer3">15</A>.
Despite the fact that the literal is a number,
we store the string representation in the token.
The string is formed by concatenating one string for each part
(the empty string is used for optional parts that are missing).
In <CODE>optExp</CODE>, as with <CODE>graphic</CODE>,
we use a type annotation so that Scala knows what type we want.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 15: A<A NAME="fig:gmllexer3"></A> token parser for numeric literals
(<TT>compiler.GmlLexer</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  def numLiteral: Parser[Token] =
    intLiteral ~ optFrac ~ optExp ^^ {
      case i ~ f ~ e =&gt; NumericLit(i + f + e)
    }

  def intLiteral: Parser[String] =
    opt('-') ~ rep1(digit) ^^ {
      case None ~ digits =&gt; digits mkString ""
      case Some(_) ~ digits =&gt; '-'::digits mkString ""
    }

  def optFrac: Parser[String] =
    opt('.' ~&gt; rep1(digit)) ^^ {
      case None =&gt; ""
      case Some(frac) =&gt; '.'::frac mkString ""
    }

  def optExp: Parser[String] =
    opt((('e': Parser[Char]) | 'E') ~&gt; intLiteral) ^^ {
      case None =&gt; ""
      case Some(exp) =&gt; "e" + exp
    }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsubsection The parse tree-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc13">4.1.2</A>&#XA0;&#XA0;The parse tree<A NAME="sec:parsetree"></A></H4><!--SEC END --><P>We shall start with a simple version of the parse tree,
which is shown in Figure&#XA0;<A HREF="#fig:term">16</A>.
This will be expanded in section&#XA0;<A HREF="#sec:analysis">4.2</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 16: The<A NAME="fig:term"></A> parse tree (incomplete).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

sealed abstract class Term

case class FunctionTerm(body: Array[Term]) extends Term
case class ArrayCtor(body: Array[Term]) extends Term
case class IntLiteral(n: Int) extends Term
case class RealLiteral(d: Double) extends Term
case class StringLiteral(s: String) extends Term
case class Operator(name: String) extends Term
case class Identifier(name: String) extends Term
case class Binder(name: String) extends Term
case object Render extends Term
case class Call(callType: CallType.Value) extends Term

object CallType extends Enumeration { val Apply, If = Value }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Nodes in the parse tree are all members of the abstract class <CODE>Term</CODE>.
Once again we use Scala&#X2019;s case classes,
which will allow us to easily traverse the parse tree using pattern matching.
There is one case for each type of GML term except Boolean literals&#X2014;we shall treat Boolean literals as operators from now on.
The cases have parameters representing either fixed pieces of data
or the node children.</P><P>We make a separate case for <CODE>Operator</CODE> terms
even though we store a name just like <CODE>Identifier</CODE> terms.
The analysis passes need to know whether or not a name is an operator,
but they don&#X2019;t need to know what the operation is.
This means the parser needs to check whether the name
exists in the operator table to know what type of term to build,
but we don&#X2019;t need look up the implementation in the table until
code generation (section&#XA0;<A HREF="#sec:codegen">4.2.4</A>).</P><P>The <CODE>Render</CODE> case is used for the GML &#X201C;render&#X201D; operator.</P><P>The <CODE>Call</CODE> case is used for the GML operators &#X201C;apply&#X201D; and &#X201C;if&#X201D;;
as in section&#XA0;<A HREF="#sec:vm">3</A> these are not treated as regular operators.
The reason we do this here is that these operators
play a significant role in the analysis passes,
so having a special case will simplify some of our later code.</P><P>The <CODE>CallType</CODE> object defines an enumeration
distinguishing between the two types of call.
In Scala, there is no language feature for enumerations.
Instead, they are defined using
the <CODE>Enumeration</CODE> class from the API,
which provides a convenient and type safe way to define a set of constants.</P><!--TOC subsubsection The parser-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc14">4.1.3</A>&#XA0;&#XA0;The parser<A NAME="sec:parser"></A></H4><!--SEC END --><P>Figure&#XA0;<A HREF="#fig:gmlparser">17</A> shows the start of the <CODE>GmlParser</CODE> object.
As with <CODE>GmlLexer</CODE>,
there are two abstract members that need to be defined.
In this case there is a type named <CODE>Tokens</CODE>
and a value named <CODE>lexical</CODE>,
from the <CODE>TokenParsers</CODE> supertrait of <CODE>StdTokenParsers</CODE>.
The definitions need to correspond to our lexer,
hence we use <CODE>StdTokens</CODE> as the type
and we create a new <CODE>GmlLexer</CODE> for the lexical value.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 17: The<A NAME="fig:gmlparser"></A> <TT>GmlParser</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

import util.parsing.combinator.syntactical.StdTokenParsers
import util.parsing.syntax.StdTokens

object GmlParser extends StdTokenParsers {
  type Tokens = StdTokens
  val lexical = new GmlLexer

  def parse(s: String): ParseResult[Array[Term]] =
    phrase(terms)(new lexical.Scanner(s))

  def apply(s: String): Array[Term] =
    parse(s) match {
      case Success(terms, _) =&gt; terms
      case e: NoSuccess =&gt; throw new Exception("syntax error: "+ e.msg)
    }

  ...
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The <CODE>parse</CODE> method parses an entire string and
returns a <CODE>ParseResult</CODE>.
If parsing is successful,
the result contains the array of terms that were parsed.
The result will also contain the remaining input,
but since <CODE>phrase</CODE> only succeeds if it reads all input
this part of the result is not interesting.
If parsing is not successful, it is possible to extract the error message
using the <CODE>msg</CODE> method.</P><P>To make the parser easier to use
we also provide an <CODE>apply</CODE> method that parses a string
and handles the result.</P><P>The rest of <CODE>GmlParser</CODE> is shown in Figure&#XA0;<A HREF="#fig:gmlparser2">18</A>.
The <CODE>processName</CODE> method first checks for the special cases of
rendering and calls,
then decides whether an identifier token is an operator or identifier.
The <CODE>processNum</CODE> method decides whether a numeric literal is an
integer or a real.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 18: The<A NAME="fig:gmlparser2"></A> GML grammar
(<TT>compiler.GmlParser</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  def terms: Parser[Array[Term]] =
    rep(term) ^^ { Array.concat(_) }

  def term: Parser[Term] =
    ( ident                 ^^ { processName(_) }
    | "{" ~&gt; terms &lt;~ "}"   ^^ { FunctionTerm(_) }
    | "[" ~&gt; terms &lt;~ "]"   ^^ { ArrayCtor(_) }
    | "/" ~&gt; ident          ^^ { Binder(_) }
    | numericLit            ^^ { processNum(_) }
    | stringLit             ^^ { StringLiteral(_) }
    )

  import runtime.Operators
  private def processName(name: String): Term =
    if (name == "render") Render
    else if (name == "apply") Call(CallType.Apply)
    else if (name == "if") Call(CallType.If)
    else if (Operators isDefinedAt name) Operator(name)
    else Identifier(name)

  private def processNum(num: String): Term =
    if (num matches "-?[0-9]+") IntLiteral(num.toInt)
    else RealLiteral(num.toDouble)
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Program analysis-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc15">4.2</A>&#XA0;&#XA0;Program analysis<A NAME="sec:analysis"></A></H3><!--SEC END --><P>The program analysis passes traverse the parse tree
and collect various kinds of information about nodes.
We store this information inside the nodes;
we will need to add some fields to the parse tree to accommodate this.</P><P>Each pass analyses one function term at a time
(the entire program will itself be treated as a function body).
The passes can assume that earlier passes
have all been performed on the function term,
and that the current pass has been performed on all nested function terms.
We will need to make sure these assumptions are justified
when we implement the main loop of the compiler in section&#XA0;<A HREF="#sec:compiler">4.3.1</A>.</P><!--TOC subsubsection Nonlocal analysis-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc16">4.2.1</A>&#XA0;&#XA0;Nonlocal analysis<A NAME="sec:nonlocals"></A></H4><!--SEC END --><P>Nonlocal analysis determines
which of the identifiers occurring in a function are nonlocal.
It allocates a context slot for each nonlocal,
and records which of them are local in the parent
and whether any are nonlocal in the parent.
Figure&#XA0;<A HREF="#fig:nonlocalsfields">19</A> shows the changes to the parse tree
to add fields for the results.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 19: Parse tree<A NAME="fig:nonlocalsfields"></A> fields for nonlocal analysis
(<TT>compiler.Term</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">import collection.mutable.{HashMap, HashSet}

case class FunctionTerm(body: Array[Term]) extends Term {
  // Nonlocal slots.
  var nonlocals: Array[String] = null
  val nonlocalMap = new HashMap[String, Int]

  // Locals from the parent that are referenced here.
  val parentLocals = new HashSet[String]

  // Are nonlocals from the parent referenced here?
  var hasParentNonlocals = false
}

case class Identifier(name: String) extends Term {
  // Is the variable bound locally?
  var isLocal = false
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The most convenient way to collect the required information
is to traverse the function body from left to right.
We keep track of the set of binders that we have seen,
as well as the nonlocal slot allocations we have made so far.
Figure&#XA0;<A HREF="#fig:nonlocals">20</A> shows the <CODE>Nonlocals</CODE> class,
which does the nonlocal analysis.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 20: Nonlocal<A NAME="fig:nonlocals"></A> analysis.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

import collection.mutable.{HashSet, Stack}

class Nonlocals(function: FunctionTerm) {
  // Binders seen.
  val locals = new HashSet[String]

  // Nonlocals allocated.
  val nonlocals = new Stack[String]

  // Do the analysis.
  def analyse: Unit = {
    traverse(function.body)
    function.nonlocals = nonlocals.toArray
    function.parentLocals ++= nonlocals
  }

  private def traverse(body: Array[Term]): Unit =
    for (term &lt;- body) term match {
      case nested @ FunctionTerm(_)   =&gt; handleNested(nested)
      case ArrayCtor(body)            =&gt; handleArrayCtor(body)
      case id @ Identifier(name)      =&gt; id.isLocal = reference(name)
      case Binder(name)               =&gt; locals + name
      case _                          =&gt;
    }

  private def handleNested(nested: FunctionTerm): Unit =
    for (name &lt;- nested.nonlocals if !reference(name)) {
      nested.parentLocals - name
      nested.hasParentNonlocals = true
    }

  private def handleArrayCtor(body: Array[Term]): Unit = {
    val startLocals = locals.clone
    traverse(body)
    locals intersect startLocals
  }

  private def reference(name: String): Boolean = {
    val isLocal = locals contains name
    if (!isLocal &amp;&amp; !(function.nonlocalMap contains name)) {
      function.nonlocalMap(name) = nonlocals.size
      nonlocals.push(name)
    }
    isLocal
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The <CODE>analyse</CODE> method traverses the function body.
At the end, it copies the slot allocations,
represented by a stack of names,
to the function&#X2019;s <CODE>nonlocals</CODE> field.
It also adds all of the nonlocals to the <CODE>parentLocals</CODE> field.
This isn&#X2019;t correct yet:
<CODE>parentLocals</CODE> should not contain <EM>all</EM> the nonlocals,
only those that are local in the parent.
When it comes time to process the parent we will need to fix up this field
by removing the entries that aren&#X2019;t local.
This is done in the code below.</P><P>Traversing the body involves pattern matching on each term in sequence.
Functions and arrays are handled by separate methods.
For identifiers,
we record that there has been a reference to the name
by calling <CODE>reference</CODE>.
This returns <CODE>true</CODE> if the variable is local;
we use this value to set the <CODE>isLocal</CODE> field of the identifier.
For binders, we add the name to the set of locals.
Other types of term are ignored.</P><P>To handle a nested function we need to reference all of its nonlocals.
If any of them are nonlocal to the function we are analysing,
this is where we need to fix up the <CODE>parentLocals</CODE> field.
We remove the nonlocal and record that there was at least one nonlocal.</P><P>To handle an array constructor we need to recursively traverse its body.
The only trick is that new binders can appear in the array,
but these won&#X2019;t be in scope after the array has ended.
We need to make sure the set of locals doesn&#X2019;t include
any new binders from the array body.
To do this,
we clone the set of locals at the start of the array
then intersect this cloned set at the end.</P><P>Finally,
when an identifier is referenced we check if it is local.
If it isn&#X2019;t, and we haven&#X2019;t seen it before,
then we allocate a slot.
We can determine the correct slot number by looking at
the number of slots that have been allocated so far
(that is, the size of the stack).</P><!--TOC subsubsection Liveness analysis-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc17">4.2.2</A>&#XA0;&#XA0;Liveness analysis<A NAME="sec:liveness"></A></H4><!--SEC END --><P>Consider the function term
</P><DIV CLASS="center">
<CODE>{/x A /y B}</CODE>
</DIV><P>
where <CODE>A</CODE> is a list of terms involving <CODE>x</CODE>
and <CODE>B</CODE> is a list of terms involving <CODE>y</CODE> but not <CODE>x</CODE>.
We will need to allocate frame slots for <CODE>x</CODE> and <CODE>y</CODE> to store
the values that the binders receive.
But since <CODE>x</CODE> does not appear in <CODE>B</CODE>,
the same slot can be reused&#X2014;the value stored there for <CODE>x</CODE> will no longer be needed
by the time we need to store the value for <CODE>y</CODE>.</P><P>We shall say that <CODE>x</CODE> is <EM>live</EM> at a given point
if there is an occurrence of <CODE>x</CODE> somewhere to the right
in the same function term,
and <EM>dead</EM> otherwise.
For example, in the above function <CODE>x</CODE> is live in <CODE>A</CODE>
(up to its last occurrence)
but dead in <CODE>B</CODE>.
The occurrence may be in a nested function or array,
as long as it isn&#X2019;t &#X201C;shadowed&#X201D; by a binder for <CODE>x</CODE>
that is in scope between the given point and <CODE>x</CODE>.</P><P>Liveness analysis calculates the point at which
each identifier in a function becomes dead.
This will allow us to optimize execution by determining
the earliest time a frame slot can be reused or the entire frame freed.
Although we reuse frame slots,
it doesn&#X2019;t make sense to reuse context slots
since these are fixed when the closure is created.
But we can still determine when the last nonlocal becomes dead,
and after this point the virtual machine
will no longer need to keep track of the <CODE>currentContext</CODE> register.</P><P>The changes to the parse tree for this pass
are shown in Figure&#XA0;<A HREF="#fig:livenessfields">21</A>.
Identifiers can become dead either in an identifier term
(if it is the last reference)
or in a nested function,
so we include information about the local(s) to free in these cases.
We can leave the frame as soon as all of the locals are dead
and no slots are being used to save registers across a call.
This can happen at an identifier, a nested function or a call,
so we add a flag for it to the base class.
We also add a flag to binders to say whether the identifier is ever used;
if it isn&#X2019;t, no frame slot will be needed at all.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 21: Parse tree<A NAME="fig:livenessfields"></A> fields for liveness analysis
(<TT>compiler.Term</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">sealed abstract class Term {
  // Should we leave the frame after this term?
  var leaveFrame = false
}

case class FunctionTerm(body: Array[Term]) extends Term {
  ...
  // Parent locals to free after the closure is built.
  var localsToFree: List[String] = Nil
}

case class Identifier(name: String) extends Term {
  ...
  // Should we free the local after pushing?
  var freeLocal = false
}

case class Binder(name: String) extends Term {
  // True if there are no references to the right.
  var isUnused = false
}

case class Call(callType: CallType.Value) extends Term {
  // Is this the last term in a function body?
  var isTailCall = false

  // Should we restore returnPointer after this call?
  var restoreReturnPointer = false

  // Should we save currentContext before this call?
  var saveCurrentContext = false

  // Should we restore currentContext after this call?
  var restoreCurrentContext = false

  // Should we free the currentContext slot after this call?
  var freeCurrentContext = false
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>We detect various things about calls during liveness analysis.
Tail calls are flagged.
We flag calls before which the current context needs to be saved
and after which it needs to be restored,
and calls after which the return pointer needs to be restored.
(The return pointer save will be added in the next pass.)
We also flag the last call to restore the current context,
which is where we can free the frame slot used for this purpose.</P><P>The start of the liveness analysis implementation
is shown in Figure&#XA0;<A HREF="#fig:liveness">22</A>.
For this pass the most convenient way to collect the required information
is to traverse the body from right to left,
which is why the body is reversed in the <CODE>for</CODE> expression.
We keep track of a number of flags for things we have seen in our traversal,
as well as the set of live locals.
The set of live locals is the set of locals we have encountered
for which we haven&#X2019;t yet encountered the binder.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 22: Liveness<A NAME="fig:liveness"></A> analysis.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

import collection.mutable.HashSet

class Liveness(function: FunctionTerm) {
  // Have we seen a (non-tail) call?
  var seenCall = false

  // Have we seen a call with nonlocal references after it?
  var seenCallWithRestore = false

  // Have we seen a nonlocal reference?
  var seenNonlocal = false

  // Have we seen a nonlocal reference since the last call?
  var seenNonlocalSinceCall = false

  // Have we seen a local reference?
  var seenLocal = false

  // Currently live locals.
  val liveLocals = new HashSet[String]

  // Do the analysis.
  def analyse: Unit = {
    function.body.lastOption match {
      case Some(c @ Call(_)) =&gt; c.isTailCall = true
      case _ =&gt;
    }
    traverse(function.body)
  }

  private def traverse(body: Array[Term]): Unit =
    for (term &lt;- body.reverse) term match {
      case nested @ FunctionTerm(_)   =&gt; handleNested(nested)
      case ArrayCtor(arrayBody)       =&gt; traverse(arrayBody)
      case id @ Identifier(_)         =&gt; handleIdentifier(id)
      case b @ Binder(_)              =&gt; handleBinder(b)
      case c @ Call(_)                =&gt; handleCall(c)
      case _                          =&gt;
    }

  ...
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The first action of liveness analysis is to check if the last term is a call.
We use <CODE>lastOption</CODE> here because the function body may be empty.
If it&#X2019;s not empty and the last term is a call,
it is flagged as a tail call&#X2014;tail calls will be ignored for the rest of this pass,
so when we refer to &#X201C;calls&#X201D; below we will mean non-tail calls.
After this check we do the traversal.
We need to take action for nested functions, identifiers, binders and calls.
Array constructors are recursively traversed,
and all other terms are ignored.</P><P>Figure&#XA0;<A HREF="#fig:liveness2">23</A> shows the code to handle identifiers and binders.
If an identifier is local we need to check if it is live.
If it is not live,
this means it is the last reference of that local and we should
both free it and add it to the set of live locals.
If we haven&#X2019;t seen any other locals this must be the last use of the frame,
so we can leave the frame at this point.
The <CODE>maybeLeaveFrame</CODE> method performs this check.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 23: Liveness analysis<A NAME="fig:liveness2"></A> of identifiers and binders
(<TT>compiler.Liveness</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def handleIdentifier(id: Identifier): Unit =
    if (id.isLocal) {
      if (!(liveLocals contains id.name)) {
        // Last reference to this local.
        id.freeLocal = true
        liveLocals + id.name
        maybeLeaveFrame(id)
      }
    } else {
      seenNonlocal = true
      seenNonlocalSinceCall = true
    }

  private def handleBinder(b: Binder): Unit =
    if (liveLocals contains b.name) liveLocals - b.name
    else b.isUnused = true

  private def maybeLeaveFrame(term: Term): Unit =
    if (!seenLocal) {
      seenLocal = true
      term.leaveFrame = true
    }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>If an identifier is nonlocal we record that we have seen a nonlocal,
and that it has been since the last call.</P><P>An identifier is dead immediately to the left of its binder,
so when we encounter a binder we should ensure
its identifier is removed from the live locals.
If the identifier wasn&#X2019;t in the live locals,
it means that the identifier wasn&#X2019;t used anywhere.
In this case we flag the binder as unused.</P><P>Figure&#XA0;<A HREF="#fig:liveness3">24</A> shows the handling of nested functions,
which is analogous to the handling of identifiers.
Each of the nested <CODE>parentLocals</CODE> that is not currently live
is added to <CODE>localsToFree</CODE> and <CODE>liveLocals</CODE>,
and we check if we should leave the frame.
If there are any nested nonlocals,
we record that we have seen a nonlocal
and that it has been since the last call.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 24: Liveness analysis<A NAME="fig:liveness3"></A> of nested functions
(<TT>compiler.Liveness</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def handleNested(nested: FunctionTerm): Unit = {
    for (name &lt;- nested.parentLocals if !(liveLocals contains name)) {
      // Closure construction is the last to use this local.
      nested.localsToFree = name :: nested.localsToFree
      liveLocals + name
      maybeLeaveFrame(nested)
    }

    if (nested.hasParentNonlocals) {
      seenNonlocal = true
      seenNonlocalSinceCall = true
    }
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Figure&#XA0;<A HREF="#fig:liveness4">25</A> shows the code to handle (non-tail) calls.
If this is this last call,
then this is the place we will need to restore the return pointer.
Since this effectively frees the slot used by the return pointer,
we check if we can leave the frame.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 25: Liveness analysis<A NAME="fig:liveness4"></A> of calls
(<TT>compiler.Liveness</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def handleCall(c: Call): Unit =
    if (!c.isTailCall) {
      // Restore returnPointer if this is the last call.
      if (!seenCall) {
        seenCall = true
        c.restoreReturnPointer = true
        maybeLeaveFrame(c)
      }

      // Save currentContext if there are nonlocal references after the call.
      if (seenNonlocal) c.saveCurrentContext = true

      // Restore currentContext if nonlocals are referenced before the next
      // call.  Free the currentContext slot on the last such occasion.
      if (seenNonlocalSinceCall) {
        seenNonlocalSinceCall = false
        c.restoreCurrentContext = true
        if (!seenCallWithRestore) {
          seenCallWithRestore = true
          c.freeCurrentContext = true
        }
      }
    }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Any call which has nonlocal references after it needs to have the
current context saved.
We flag all calls satisfying this condition,
although only the first call needs to actually save the register
because we leave the value in place for later calls;
we don&#X2019;t free the slot until after the last time it needs to be restored.
In the next pass we will pick out the first call
and reset the flag for all the others.</P><P>Restoring the current context needs to be done
if any nonlocals are referenced before the next call.
Nonlocals <EM>after</EM> the next call don&#X2019;t count,
because in that case the restore will occur at the later call.
In our backwards traversal we set the flag if
we have seen any nonlocals since a call,
and, since this term is itself a call,
we record that we have not seen any nonlocals since a call.
This is also where we check if the restore is the last one,
in which case we set the flag for freeing the current context slot.</P><!--TOC subsubsection Local slot allocation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc18">4.2.3</A>&#XA0;&#XA0;Local slot allocation<A NAME="sec:locals"></A></H4><!--SEC END --><P>The slot allocation pass allocates a slot number for each of the locals.
We traverse left to right over the function body,
allocating slots when a binder is encountered
and using the allocated slot when a local identifier is encountered.
When the liveness information tells us that a slot can be freed,
we add it to a &#X201C;free list&#X201D;.
Each time we allocate a slot
we first check if there are any available on the free list.
A new slot is only allocated if none are currently free.</P><P>Figure&#XA0;<A HREF="#fig:slotallocfields">26</A> shows
the extra fields we need in the parse tree.
In the base class we define <CODE>enterFrame</CODE>,
which corresponds to the <CODE>leaveFrame</CODE> field from the previous pass.
The remaining new fields store information about allocated slots.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 26: Parse tree<A NAME="fig:slotallocfields"></A> fields for slot allocation
(<TT>compiler.Term</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">sealed abstract class Term {
  // Should we enter the frame before this term?
  var enterFrame = false

  ...
}

case class FunctionTerm(body: Array[Term]) extends Term {
  ...
  // Where to find nonlocal bindings in the parent.
  var locations: Array[Location] = null

  // Number of frame slots required.
  var frameSize = -1
}

case class Identifier(name: String) extends Term {
  ...
  // Where is the binding stored?
  var location: Location = null
}

case class Binder(name: String) extends Term {
  ...
  // Which frame slot is the value stored in?
  var frameSlot = -1
}

case class Call(callType: CallType.Value) extends Term {
  ...
  // Should we save returnPointer before this call?
  var saveReturnPointer = false

  // In which frame slots are the registers stored?
  var returnPointerSlot = -1
  var currentContextSlot = -1
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The <CODE>Location</CODE> type is used where
the location could either be in the frame or in the context.
Its implementation is in Figure&#XA0;<A HREF="#fig:location">27</A>.
Each case has a parameter for the slot number;
the case itself says whether the slot is in the frame or in the context.
When it comes to generating code,
we will want to push the value at the location.
The <CODE>bytecode</CODE> method returns the appropriate bytecode for this.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 27: Locations<A NAME="fig:location"></A> where bindings are stored.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

import runtime.{Bytecode, PushLocal, PushNonlocal}

sealed abstract class Location {
  def bytecode: Bytecode
}

case class FrameSlot(slot: Int) extends Location {
  def bytecode = PushLocal(slot)
}

case class ContextSlot(slot: Int) extends Location {
  def bytecode = PushNonlocal(slot)
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The start of the <CODE>SlotAlloc</CODE> class
is shown in Figure&#XA0;<A HREF="#fig:slotalloc">28</A>.
It maintains a map of the current slot allocations, the free list,
and a number of flags.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 28: Slot<A NAME="fig:slotalloc"></A> allocation.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

import collection.mutable.HashMap

class SlotAlloc(function: FunctionTerm) {
  // Current slot allocation.
  val frameSlots = new HashMap[String, Int]

  // Number of slots allocated.
  var numFrameSlots = 0

  // Frame slots no longer in use.
  var freeList: List[Int] = Nil

  // Have we entered the frame?
  var frameEntered = false

  // Have we saved returnPointer?
  var savedReturnPointer = false
  val nameReturnPointer = "_returnPointer"

  // Have we saved currentContext?
  var savedCurrentContext = false
  val nameCurrentContext = "_currentContext"

  // Allocate the slots.
  def allocate: Unit = {
    traverse(function.body)
    function.frameSize = numFrameSlots
  }

  private def traverse(body: Array[Term]): Unit =
    for (term &lt;- body) term match {
      case nested @ FunctionTerm(_)   =&gt; handleNested(nested)
      case ArrayCtor(arrayBody)       =&gt; traverse(arrayBody)
      case id @ Identifier(_)         =&gt; handleIdentifier(id)
      case b @ Binder(_)              =&gt; handleBinder(b)
      case c @ Call(_)                =&gt; handleCall(c)
      case _                          =&gt;
    }

  ...
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>We allocate slots for the virtual machine registers
in the same way that we allocate them for locals.
To do this we need a fixed name for each of the registers.
The fields <CODE>nameReturnPointer</CODE> and <CODE>nameCurrentContext</CODE>
provide these names.
We have chosen names beginning with an underscore
because these are not valid GML identifiers&#X2014;the parser never produces binders or identifiers with these names,
so there is no possibility of an accidental conflict
with a user&#X2019;s GML program.</P><P>Slot allocation is performed by traversing over the function body
in a similar way to previous passes.
After the traversal is complete,
we set the function frame size to the value of <CODE>numFrameSlots</CODE>.
This value is equal to the maximum number of slots used
at any point in the function.
Ultimately, this will determine the size we use
when entering and leaving the frame for this function.</P><P>Support methods for local slot allocation
are shown in Figure&#XA0;<A HREF="#fig:slotalloc2">29</A>.
These include methods for handling the free list as described earlier,
and a method <CODE>maybeEnterFrame</CODE>
which corresponds to <CODE>maybeLeaveFrame</CODE> from the previous section.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 29: Support methods<A NAME="fig:slotalloc2"></A> for slot allocation
(<TT>compiler.SlotAlloc</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def maybeEnterFrame(term: Term): Unit =
    if (!frameEntered) {
      frameEntered = true
      term.enterFrame = true
    }

  private def allocateSlot(name: String): Int = {
    var slot = -1
    freeList match {
      case firstFree :: rest =&gt;
        slot = firstFree
        freeList = rest
      case Nil =&gt;
        slot = numFrameSlots
        numFrameSlots += 1
    }
    frameSlots(name) = slot
    slot
  }

  private def freeSlot(name: String): Unit = {
    freeList = frameSlots(name) :: freeList
    frameSlots.removeKey(name)
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The code for handling nested functions is shown in Figure&#XA0;<A HREF="#fig:slotalloc3">30</A>.
We need to set the <CODE>locations</CODE> field to an array containing
a <CODE>Location</CODE> for each of the nonlocals in the function.
When we emit bytecode to construct a closure for this function,
the locations field will tell us
where to find all the bindings for the context.
The location depends on whether the identifier is
local or nonlocal in the parent:
local bindings are found in the frame slot that has been allocated,
and nonlocal bindings are found in the context slot
given by the parent function&#X2019;s <CODE>nonlocalMap</CODE>.
We use a higher-order &#X201C;map&#X201D; expression
(really just a method call to <CODE>map</CODE> with a function argument)
to write this concisely.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 30: Slot allocation<A NAME="fig:slotalloc3"></A> for nested functions
(<TT>compiler.SlotAlloc</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def handleNested(nested: FunctionTerm): Unit = {
    // Set the locations of the nested nonlocals.
    nested.locations = nested.nonlocals map { arg =&gt;
      if (nested.parentLocals contains arg) FrameSlot(frameSlots(arg))
      else ContextSlot(function.nonlocalMap(arg))
    }

    // Free all parent locals whose last appearance is in the nested function.
    nested.localsToFree.foreach(freeSlot)
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The other task for handling nested functions is to free all of the locals
in the <CODE>localsToFree</CODE> field.
This needs to be done <EM>after</EM> creating the <CODE>locations</CODE> array
because freeing a slot removes its entry from <CODE>frameSlots</CODE>,
but that entry would have been needed to get the correct frame slot location.</P><P>Identifiers and binders are handled in Figure&#XA0;<A HREF="#fig:slotalloc4">31</A>.
Identifiers are handled similarly to nested functions:
we need to set the location and then free the identifier if it is local.
For a binder, if it is used at all then it needs a slot allocated.
Since this may be the first time any frame slot is used,
we need to check whether to enter the frame.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 31: Slot allocation<A NAME="fig:slotalloc4"></A> for identifiers and binders
(<TT>compiler.SlotAlloc</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def handleIdentifier(id: Identifier): Unit =
    if (id.isLocal) {
      id.location = FrameSlot(frameSlots(id.name))
      if (id.freeLocal) freeSlot(id.name)
    } else {
      id.location = ContextSlot(function.nonlocalMap(id.name))
    }

  private def handleBinder(b: Binder): Unit =
    if (!b.isUnused) {
      maybeEnterFrame(b)
      b.frameSlot = allocateSlot(b.name)
    }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The last piece of the slot allocation pass is for handling calls,
and is shown in Figure&#XA0;<A HREF="#fig:slotalloc5">32</A>.
As in the previous pass, we don&#X2019;t need to do anything for tail calls.
For non-tail calls,
we need to deal with the saving and restoring of the registers.
This involves setting the flag and slot location in the <CODE>Call</CODE>,
and possibly freeing the slot.
Since this might be the first time a frame slot is used,
we again need to check whether to enter the frame.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 32: Slot allocation<A NAME="fig:slotalloc5"></A> for calls
(<TT>compiler.SlotAlloc</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def handleCall(c: Call): Unit =
    if (!c.isTailCall) {
      maybeEnterFrame(c)

      if (!savedReturnPointer) {
        savedReturnPointer = true
        c.saveReturnPointer = true
        c.returnPointerSlot = allocateSlot(nameReturnPointer)
      }

      if (c.saveCurrentContext) {
        if (!savedCurrentContext) {
          savedCurrentContext = true
          c.currentContextSlot = allocateSlot(nameCurrentContext)
        } else {
          c.saveCurrentContext = false
        }
      }

      if (c.restoreReturnPointer) {
        c.returnPointerSlot = frameSlots(nameReturnPointer)
        freeSlot(nameReturnPointer)
      }

      if (c.restoreCurrentContext)
        c.currentContextSlot = frameSlots(nameCurrentContext)

      if (c.freeCurrentContext)
        freeSlot(nameCurrentContext)
    }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The return pointer must be saved before the first call,
so we do this the first time
then set <CODE>savedReturnPointer</CODE> to say that this has been done.
The current context needs to be saved if the <CODE>saveCurrentContext</CODE>
flag was set in the previous pass,
but recall that we only wanted to do this for the first such call.
Therefore, we set <CODE>savedCurrentContext</CODE> on the first occasion,
and on later occasions we clear the flag in the <CODE>Call</CODE>
rather than doing the save.</P><P>Restoring the registers is done based on
the <CODE>restoreReturnPointer</CODE> and <CODE>restoreCurrentContext</CODE> flags.
For the return pointer,
there will only be one restore so we unconditionally free the slot.
The current context may be restored multiple times,
which is why we needed a separate <CODE>freeCurrentContext</CODE> flag.
We only free the slot if this is set.</P><!--TOC subsubsection Code generation-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc19">4.2.4</A>&#XA0;&#XA0;Code generation<A NAME="sec:codegen"></A></H4><!--SEC END --><P>Now that we have done the hard analysis work,
code generation is relatively easy.
It works in a similar way to the previous passes,
in that we traverse one function body at a time.
In this case, however, we generate code for the function as a side effect.</P><P>Figure&#XA0;<A HREF="#fig:codegenfields">33</A> shows
the last addition we will need to make to the parse tree.
This is the address of the start of the bytecode generated for the function,
which we fill when we start to generate the code.
As with the analysis passes,
we generate code for all nested functions
before we generate code for the parent,
so the address will be valid in the nested functions
by the time we need to create closures for them in the parent.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 33: Parse tree<A NAME="fig:codegenfields"></A> fields for code generation
(<TT>compiler.Term</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">case class FunctionTerm(body: Array[Term]) extends Term {
  ...
  // Address of function in generated bytecode.
  var address = -1
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The start of the code generator is shown in Figure&#XA0;<A HREF="#fig:codegen">34</A>.
The <CODE>code</CODE> parameter is a bytecode stack where we will generate code&#X2014;an instruction is generated by pushing it onto this stack.
The next address that will be used is given by the size of the code stack;
we use this to set the function address at the start of <CODE>generate</CODE>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 34: Code<A NAME="fig:codegen"></A> generation.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

import collection.mutable.Stack
import runtime._

class CodeGen(function: FunctionTerm, code: Stack[Bytecode]) {
  // Generate code for the function.
  def generate: Unit = {
    function.address = code.size
    traverse(function.body)
    function.body.lastOption match {
      case Some(c @ Call(_)) if (c.isTailCall) =&gt;
      case _ =&gt; code push Return
    }
  }

  private def traverse(body: Array[Term]): Unit =
    for (term &lt;- body) term match {
      case nested @ FunctionTerm(_)   =&gt; generateNested(nested)
      case ArrayCtor(arrayBody)       =&gt; generateArrayCtor(arrayBody)
      case id @ Identifier(_)         =&gt; generateIdentifier(id)
      case b @ Binder(_)              =&gt; generateBinder(b)
      case c @ Call(_)                =&gt; generateCall(c)
      case Render                     =&gt; code push DoRender
      case Operator(name)             =&gt; code push Op(Operators(name))
      case IntLiteral(n)              =&gt; code push PushInt(n)
      case RealLiteral(d)             =&gt; code push PushReal(d)
      case StringLiteral(s)           =&gt; code push PushString(s)
    }

  ...
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>After we have traversed the body
we will need to generate a <CODE>Return</CODE> instruction
unless the last term was a tail call.
The <CODE>match</CODE> expression tests for this case first,
in which case it generates nothing,
and generates the instruction in all other cases
(including when the function body is empty).</P><P>Traversal is from left to right.
Literals and operators only require a single instruction to be generated;
in the case of operators other than <CODE>render</CODE>
we need to look up the operator implementation
in the <CODE>Operators</CODE> object.
The other cases are handled by separate methods.</P><P>Code generation of nested functions is shown in Figure&#XA0;<A HREF="#fig:codegen2">35</A>.
Since both the <CODE>enterFrame</CODE> and the <CODE>leaveFrame</CODE> flags
could be set for this type of term,
we check these at the start and end of the method, respectively.
Each check needs to generate the corresponding bytecode if the flag is set.
We will want to use the checks below, as well,
so we define methods <CODE>maybeEnterFrame</CODE> and <CODE>maybeLeaveFrame</CODE>
to do the checks.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 35: Code generation<A NAME="fig:codegen2"></A> of nested functions
(<TT>compiler.CodeGen</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def generateNested(nested: FunctionTerm): Unit = {
    maybeEnterFrame(nested)
    code push PushInt(nested.address)
    nested.locations foreach { code push _.bytecode }
    code push MakeClosure(nested.locations.length)
    maybeLeaveFrame(nested)
  }

  private def maybeEnterFrame(term: Term): Unit =
    if (term.enterFrame) code push EnterFrame(function.frameSize)

  private def maybeLeaveFrame(term: Term): Unit =
    if (term.leaveFrame) code push LeaveFrame(function.frameSize)
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>In between the calls to handle the frame,
we generate code that constructs a closure for the nested function.
We first generate code to push the bytecode address and all the arguments,
whose locations can be found in the <CODE>locations</CODE> field
of the nested function.
For the arguments,
we use the <CODE>foreach</CODE> method
in a way similar to <CODE>map</CODE> from Figure&#XA0;<A HREF="#fig:slotalloc3">30</A>.
We then generate a <CODE>MakeClosure</CODE> instruction,
passing it the number of arguments we have just pushed.
At runtime, all of the arguments we pushed will be converted into a context,
and this will be combined with the address to form the closure.</P><P>Figure&#XA0;<A HREF="#fig:codegen3">36</A> shows the code generation of
array constructors, identifiers and binders.
To construct an array we just generate the code for the array body,
but surround it with <CODE>StartArray</CODE> and <CODE>EndArray</CODE> instructions.
For identifiers, we generate the bytecode
to push the value at its location onto the data stack.
We also check whether to leave the frame afterwards.
For binders, we first check whether to enter the frame.
The bytecode for the binding depends on whether the binder is used or not.
If it&#X2019;s unused we generate <CODE>PopUnused</CODE>,
otherwise we generate <CODE>PopLocal</CODE>,
with the correct frame slot for that binder.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 36: Code generation<A NAME="fig:codegen3"></A> of array constructors,
identifiers and binders (<TT>compiler.CodeGen</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def generateArrayCtor(body: Array[Term]): Unit = {
    code push StartArray
    traverse(body)
    code push EndArray
  }

  private def generateIdentifier(id: Identifier): Unit = {
    code push id.location.bytecode
    maybeLeaveFrame(id)
  }

  private def generateBinder(b: Binder): Unit = {
    maybeEnterFrame(b)
    if (b.isUnused) code push PopUnused
    else code push PopLocal(b.frameSlot)
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Code generation of calls is shown in Figure&#XA0;<A HREF="#fig:codegen4">37</A>.
Prior to the call we check whether to enter the frame,
and check whether to save each of the two virtual machine registers.
The call itself is just the bytecode corresponding to the call type.
After the call we check whether to restore the registers
and whether to leave the frame.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 37: Code generation<A NAME="fig:codegen4"></A> of calls
(<TT>compiler.CodeGen</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  private def generateCall(c: Call): Unit = {
    maybeEnterFrame(c)
    if (c.saveReturnPointer) code push SaveReturnPtr(c.returnPointerSlot)
    if (c.saveCurrentContext) code push SaveContext(c.currentContextSlot)
    c.callType match {
      case CallType.Apply =&gt; code push Apply(c.isTailCall)
      case CallType.If    =&gt; code push If(c.isTailCall)
    }
    if (c.restoreCurrentContext) code push RestoreContext(c.currentContextSlot)
    if (c.restoreReturnPointer) code push RestoreReturnPtr(c.returnPointerSlot)
    maybeLeaveFrame(c)
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Tying it together-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc20">4.3</A>&#XA0;&#XA0;Tying it together<A NAME="sec:tying"></A></H3><!--SEC END --><P>In this section we implement a <CODE>Compiler</CODE> class that
brings together the analysis passes,
and a top level application for parsing and running GML programs.
At this stage we will have a functioning system,
although obviously it won&#X2019;t be possible to do any rendering
until we implement the operators for it in section&#XA0;<A HREF="#sec:rendering">5</A>.</P><!--TOC subsubsection The <TT>Compiler</TT> class-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc21">4.3.1</A>&#XA0;&#XA0;The <TT>Compiler</TT> class<A NAME="sec:compiler"></A></H4><!--SEC END --><P>The <CODE>Compiler</CODE> class is shown in Figure&#XA0;<A HREF="#fig:compiler">38</A>.
It performs the analysis and generates code for all functions in a program,
making sure that the assumptions about the order of processing are met.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 38: The<A NAME="fig:compiler"></A> <TT>Compiler</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

import collection.mutable.Stack
import runtime.Bytecode

class Compiler {
  // Code is generated here.
  val codeStack = new Stack[Bytecode]
  def code = codeStack.toArray

  // Compile a function, after recursively compiling all nested functions.
  def compile(function: FunctionTerm): Unit = {
    recursiveCompile(function.body)
    new Nonlocals(function).analyse
    new Liveness(function).analyse
    new SlotAlloc(function).allocate
    new CodeGen(function, codeStack).generate
  }

  // Compile all nested functions in the body.
  def recursiveCompile(body: Array[Term]): Unit =
    for (term &lt;- body) term match {
      case nested @ FunctionTerm(_)   =&gt; compile(nested)
      case ArrayCtor(arrayBody)       =&gt; recursiveCompile(arrayBody)
      case _                          =&gt;
    }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Recall that there were two assumptions:
each pass of a function comes after that pass for all of the nested functions,
and comes after the earlier passes for that function.
It is easy to see that the code in the <CODE>compile</CODE> method
satisfies both of these assumptions,
because the call to <CODE>recursiveCompile</CODE> comes first
and the remaining calls are in the correct order.</P><P>When we do the recursive compile,
we mustn&#X2019;t forget to check inside array constructors for nested functions.
This is why, aside from calling <CODE>compile</CODE> for function terms,
it also calls itself recursively for array constructors.
Functions occurring inside arrays will thus be found,
as will functions inside arrays inside arrays, and so on.</P><P>All code generators are passed the <CODE>codeStack</CODE> value,
so they all push their code onto the one stack.
Once the program has been compiled
the resulting bytecode can be extracted with the <CODE>code</CODE> method,
which converts <CODE>codeStack</CODE> to the required array.</P><!--TOC subsubsection The <TT>Main</TT> object-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc22">4.3.2</A>&#XA0;&#XA0;The <TT>Main</TT> object<A NAME="sec:main"></A></H4><!--SEC END --><P>The <CODE>Main</CODE> object in Figure&#XA0;<A HREF="#fig:main">39</A> implements an application
that reads in a GML program, compiles and executes it,
then prints out the contents of the data stack.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 39: The<A NAME="fig:main"></A> <TT>Main</TT> object.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package compiler

import io.Source
import runtime._

object Main {
  def main(args: Array[String]): Unit = {
    // Get the input source.
    val in = if (args.length &gt; 0) Source.fromFile(args(0))
             else Source.fromInputStream(System.in)

    // Parse the input and wrap the resulting terms in a function.
    val main = FunctionTerm(GmlParser(in.getLines.mkString))

    // Compile to bytecode.
    val compiler = new Compiler
    compiler.compile(main)

    // At the top level, it is an error if there are any nonlocals.
    if (main.nonlocals.length &gt; 0) {
      println("Error: unbound identifier(s): "+ main.nonlocals.mkString(" "))
      exit(1)
    } else {
      // Execute the bytecode.
      val vm = new VM(compiler.code)
      try {
        vm.execute(main.address)
      } catch {
        case e =&gt;
          println(e.getMessage)
          // Close off any unfinished arrays.
          while (vm.data.metaStackTop != 0) vm.data.endArray
      }
      println("Data stack:")
      while (vm.data.stackTop &gt; 0) println(vm.data.pop)
    }
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Input is read from the file given by the first argument,
if there are any command line arguments,
otherwise it is read from standard input.</P><P>The parsed terms are wrapped in a function term before being compiled.
This doesn&#X2019;t change the meaning of the GML program,
because evaluating the terms directly is equivalent to
applying the function term in an empty environment.
Note that if the list of nonlocals for the compiled function
is <EM>not</EM> empty, this is a problem.
It means some identifiers being referred to are not bound to any value,
so in this case we report an error and exit.</P><P>We then execute the code for <CODE>main</CODE> and print out the data stack.
The call to <CODE>vm.execute</CODE> is performed in a <CODE>try</CODE> block
in order to catch type errors and underflow errors in the GML programs,
which are not detected by the compiler.
If an error is caught,
we print its message then fix up the data stack before printing it out.
We need to do this because the error may have occurred when building an array,
in which case the meta-stack would not be empty
and the code to print the stack would not work properly.</P><P>The next section has some GML examples that you can now try out.</P><!--TOC subsubsection Some GML Examples-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc23">4.3.3</A>&#XA0;&#XA0;Some GML Examples<A NAME="sec:gmlexamples"></A></H4><!--SEC END --><P>Our first example is a standard for toy functional programming languages,
the factorial function.
Consider the following GML code:
</P><PRE CLASS="verbatim">  { /self /n
    n 2 lessi
      { 1 }
      { n 1 subi self self apply n muli }
    if
  } /fac
</PRE><P>This code uses <EM>anonymous recursion</EM> to implement
a form of the factorial function.
The first input, which <CODE>self</CODE> will be bound to,
is a closure that is to be called for the recursive case.
The idea is that any time we want to apply <CODE>fac</CODE>,
we should push two copies of it:
one that is used by the apply operator,
and one that <CODE>self</CODE> gets bound to.
The body of the function compares <CODE>n</CODE>,
and if it is less than two then one is returned.
If not then we subtract one from <CODE>n</CODE> and do the recursive call,
remembering to push two copies of the closure,
then multiply the result by <CODE>n</CODE>.</P><P>This function can be used as follows:
</P><PRE CLASS="verbatim">  8 fac fac apply
</PRE><P>The result will be a data stack containing 40320.</P><P>This is a little awkward to use&#X2014;forgetting to mention <CODE>fac</CODE> twice will lead to a stack underflow
or type error.
We can add the following code to help with this.
</P><PRE CLASS="verbatim">  { fac fac apply } /fac
</PRE><P>The <CODE>fac</CODE> inside this function refers to the binding we made above.
The function applies <CODE>fac</CODE> to whtaever is on top of the stack,
ensuring that the extra copy is passed as required.
The binding uses the same name <CODE>fac</CODE>,
which means that this binding shadows the previous one.
This doesn&#X2019;t affect the code inside the function,
only the code that comes after this definition,
so any code after this point can contain:
</P><PRE CLASS="verbatim">  8 fac apply
</PRE><P>and expect the right result.</P><P>The aim of our next example is a generic function that takes
an integer <CODE>n</CODE> and a function <CODE>f</CODE>.
The effect is that <CODE>f</CODE> is applied <CODE>n</CODE> times.
We again start with a version that uses anonymous recursion,
then shadow it with the real version:
</P><PRE CLASS="verbatim">  { /self /n /f
    n 1 lessi
      {}
      { f apply f n 1 subi self self apply }
    if
  } /repeat

  { repeat repeat apply } /repeat
</PRE><P>If <CODE>n</CODE> is less than one then we call the identity function
which does nothing.
Otherwise we apply <CODE>f</CODE> once then make the recursive call.</P><P>For example, we can create an array containing twenty zeroes with:
</P><PRE CLASS="verbatim">  [ { 0 } 20 repeat apply ]
</PRE><P>Another simple use of <CODE>repeat</CODE> is to create a Fibonacci sequence
on the data stack:
</P><PRE CLASS="verbatim">  { /n
    { /b /a a b a b addi } n repeat apply
  } /fib
</PRE><P>Here the nested function reads the top two numbers
(that is, pops them then pushes them again so as to leave
the data stack unchanged)
then pushes their sum.
Applying the nested function once extends a Fibonacci sequence by one.</P><P>For example,
the following array contains the first twelve numbers of
the Fibonacci sequence starting with two ones:
</P><PRE CLASS="verbatim">  [ 1 1 10 fib apply ]
</PRE><P>The output from our program is:
</P><PRE CLASS="verbatim">  Data stack:
  [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144]
</PRE><!--TOC section Rendering-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc24">5</A>&#XA0;&#XA0;Rendering<A NAME="sec:rendering"></A></H2><!--SEC END --><!--NAME rendering.html-->
<!--TOC subsection Points and rays-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">5.1</A>&#XA0;&#XA0;Points and rays<A NAME="sec:point"></A></H3><!--SEC END --><P>In GML, points are used to represent positions in 3D space,
to represent colors,
and can also be used as a general data structure.
Figure&#XA0;<A HREF="#fig:point">40</A> shows the implementation of a <CODE>Point</CODE> class,
which we shall use for these three purposes.
We shall also use it internally in the rendering package
to represent the velocity of a ray,
which is a vector quantity.<SUP><A NAME="text4" HREF="#note4">4</A></SUP></P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 40: The<A NAME="fig:point"></A> <TT>Point</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

case class Point(x: Double, y: Double, z: Double) {
  import Math.{max, sqrt}

  // vector sum, difference
  def +(p: Point) = Point(x+p.x, y+p.y, z+p.z)
  def -(p: Point) = Point(x-p.x, y-p.y, z-p.z)

  // scalar product, quotient
  def *(s: Double) = Point(x*s, y*s, z*s)
  def /(s: Double) = *(1/s)

  // vector dot product
  def dot(p: Point) = x*p.x + y*p.y + z*p.z

  // vector dot product on XZ plane
  def dotXZ(p: Point) = x*p.x + z*p.z

  // vector dot product with Y-conjugate
  def conjY(p: Point) = x*p.x - y*p.y + z*p.z

  // vector cross product
  def cross(p: Point) = Point(y*p.z - z*p.y, z*p.x - x*p.z, x*p.y - y*p.x)

  // coordinate-wise product
  def times(p: Point) = Point(x*p.x, y*p.y, z*p.z)

  // maximum value of any coordinate
  def maxCoordinate = max(x, max(y, z))

  // length squared
  def squared = dot(this)

  // additive inverse
  def neg = *(-1)

  // normalize
  def unit = this / sqrt(this squared)
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>A number of methods implementing vector algebra operations are provided.
Most of these are standard, such as dot and cross product.
The <CODE>dotXZ</CODE> is the dot product of the vectors
projected onto the X-Z plane.
It is the same as the dot product, except without the middle term.
The &#X201C;<I>y</I>-conjugate&#X201D; of a point is a point with the same <I>x</I> and <I>z</I> values,
but the <I>y</I> value is negated.
The dot product with a <I>y</I>-conjugate is therefore the same as the dot product,
except with the middle term negated.</P><P>Note that we provide a method for the length squared, but not the length.
Calculating the latter requires an expensive <CODE>sqrt</CODE> operation,
so we avoid it as much as possible.
In most cases we just want to compare two lengths to see which is longer;
for this purpose it suffices to compare the square of the lengths instead.</P><P>The <CODE>times</CODE> method is for dealing with color.
If a light of one color shines on a surface of another color,
the resulting visible color will be the coordinate-wise product of the two.
The <CODE>maxCoordinate</CODE> method is also for dealing with color;
it is used to determine whether a color is so close to black
that it can be treated as such.</P><P>We will find it convenient to use the <CODE>Ray</CODE> class,
shown in Figure&#XA0;<A HREF="#fig:ray">41</A>.
This simple class consists of two point parameters:
<CODE>origin</CODE>, which is a point in 3D space,
and a <CODE>velocity</CODE>, which is a vector.
A ray can be thought of as starting at <CODE>origin</CODE> at time zero
and travelling with <CODE>velocity</CODE> indefinitely.
Applying a ray to a time value gives the location of the ray at that time.
The <CODE>unit</CODE> method returns a ray with the same origin and direction,
but a speed of one.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 41: The<A NAME="fig:ray"></A> <TT>Ray</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

case class Ray(origin: Point, velocity: Point) {
  // Where will the ray extend to after the given time?
  def apply(time: Double): Point = origin + velocity * time

  // Return the ray with normalized velocity.
  def unit = Ray(origin, velocity.unit)
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Lights-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc26">5.2</A>&#XA0;&#XA0;Lights<A NAME="sec:lights"></A></H3><!--SEC END --><P>Each light in GML has its own color, and there are three kinds of light.
The different kinds of light are characterised by three behaviours:
how the direction towards the light changes as the observer moves,
how much the light is attenuated due to the position of the observer,
and whether an object at a given distance will block
the light reaching an observer.</P><P>The <CODE>Light</CODE> class in Figure&#XA0;<A HREF="#fig:light">42</A>
captures the behaviour of lights.
We use an abstract value for the color,
and three abstract methods for the behaviours.
The methods correspond directly to the behaviours in the previous paragraph,
except that <CODE>isBlocked</CODE> takes the distance squared as its argument.
As mentioned earlier,
we use the lengths squared for comparison
to save ourselves the expense of calculating the square roots.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 42: The<A NAME="fig:light"></A> <TT>Light</TT> base class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

sealed abstract class Light {
  // The color of the light.
  val color: Point

  // Return a unit vector pointing towards the light from point.
  def directionFrom(point: Point): Point

  // Attenuation of the light at a point, given the unit ray pointing
  // towards the light.
  def attenuation(ray: Ray): Double

  // Is the light blocked at point by an object at the given distance
  // squared?
  def isBlocked(point: Point, dSqr: Double): Boolean
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Plain directional lights and point lights
are shown in Figure&#XA0;<A HREF="#fig:pointlight">43</A>.
The definition of <CODE>PlainLight</CODE> is simple:
plain lights are always blocked by an object no matter how far away,
they are never attenuated,
and the direction to them from a point is a constant,
equal to the unit vector in the opposite direction
to the direction of the light.
We use a <CODE>val</CODE> member to store the vector towards the light,
which means that it will only be calculated once
instead of each time we want to know the direction.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 43: The<A NAME="fig:pointlight"></A> <TT>PlainLight</TT> and
<TT>PointLight</TT> classes.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">case class PlainLight(direction: Point, color: Point) extends Light {
  // Unit vector pointing directly towards the light.
  val towards = direction.neg.unit
  def directionFrom(point: Point) = towards
  def attenuation(ray: Ray) = 1
  def isBlocked(point: Point, dSqr: Double) = true
}

case class PointLight(position: Point, color: Point) extends Light {
  def directionFrom(point: Point) = (position - point).unit
  def attenuation(ray: Ray) = 100 / (99 + (position - ray.origin).squared)
  def isBlocked(point: Point, dSqr: Double) = (position - point).squared &gt; dSqr
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The definition of <CODE>Pointlight</CODE> is almost as simple.
Light is blocked by an object if
the light source is further away than the object,
attenuation is by the formula given in the specification,
and the direction from a point is found with vector subtraction.</P><P>The behaviour of spotlights is the same as point lights,
except that the attenuation is modified by a factor,
or may be cut off entirely,
depending on the angle between the direction from the observer
and the direction directly towards the light.
We therefore make the <CODE>SpotLight</CODE> class extend <CODE>PointLight</CODE>
and override the <CODE>attenuation</CODE> method.
The code is in Figure&#XA0;<A HREF="#fig:spotlight">44</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 44: The<A NAME="fig:spotlight"></A> <TT>SpotLight</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">import Math.{cos, pow, toRadians}

case class SpotLight(
              override val position: Point,
              at: Point,
              override val color: Point,
              cutoff: Double,
              exponent: Double
           ) extends PointLight(position, color)
{
  // Unit vector pointing directly towards the light.
  val towards = (position - at).unit

  // Cosine of the cutoff angle.
  val cosCutoff = cos(toRadians(cutoff))

  override def attenuation(ray: Ray) = {
    val cos = ray.velocity dot towards
    if (cos &lt; cosCutoff) 0
    else pow(cos, exponent) * super.attenuation(ray)
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P><CODE>SpotLight</CODE> has three parameters that its superclass does not.
The <CODE>at</CODE> parameter is a point at which the cone of light is centered.
It could be any distance from the light.
The <CODE>cutoff</CODE> parameter is the angle at which the cone of light expands.
Outside this cone no light is produced.
Inside the cone the rate at which the light decays with increasing angle
is controlled by the <CODE>exponent</CODE> parameter.
The parameters in common with <CODE>PointLight</CODE>
require the <CODE>override val</CODE> prefix
because <CODE>PointLight</CODE> is a case class
that already exports these names for <EM>its</EM> parameters.</P><P>We store the direction towards the light in a <CODE>val</CODE> member,
as we did with plain lights.
We also store the cosine of the cutoff angle,
since we can compare the cosines of angles much like we can compare
the squares of lengths,
although we need to reverse the comparison because
cosine is <EM>decreasing</EM> over the range we are interested in.
The cosine of the angle is easy to calculate:
it is just the dot product of the ray velocity and the <CODE>towards</CODE> value
(we also need to divide by the length of each vector,
but here we have arranged things so that these values are always one).</P><P>To complete the calculation,
<CODE>SpotLight</CODE> still needs to call the method in the superclass
to find out how much the light is attenuated
due to the distance from the source.
The <CODE>super</CODE> keyword is used for this purpose.</P><!--TOC subsection Scene construction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc27">5.3</A>&#XA0;&#XA0;Scene construction<A NAME="sec:scene"></A></H3><!--SEC END --><P>We are now in a position to add scene construction to the virtual machine.
Figure&#XA0;<A HREF="#fig:scene">45</A> shows the <CODE>Scene</CODE> type,
which is used to represent constructed scenes at runtime.
Each case corresponds directly to
one of the GML operators for scene construction,
with parameters corresponding to the operator inputs.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 45: The<A NAME="fig:scene"></A> <TT>Scene</TT> type.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

sealed abstract class Scene

case class Sphere(surface: ClosureValue) extends Scene
case class Cube(surface: ClosureValue) extends Scene
case class Cylinder(surface: ClosureValue) extends Scene
case class Cone(surface: ClosureValue) extends Scene
case class Plane(surface: ClosureValue) extends Scene

case class Union(left: Scene, right: Scene) extends Scene
case class Intersect(left: Scene, right: Scene) extends Scene
case class Difference(left: Scene, right: Scene) extends Scene

case class RotateX(scene: Scene, degrees: Double) extends Scene
case class RotateY(scene: Scene, degrees: Double) extends Scene
case class RotateZ(scene: Scene, degrees: Double) extends Scene
case class Translate(scene: Scene, dx: Double, dy: Double, dz: Double)
        extends Scene
case class Scale(scene: Scene, rx: Double, ry: Double, rz: Double)
        extends Scene
case class UScale(scene: Scene, r: Double) extends Scene
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Scenes, as well as points and lights are included as values
by adding extra cases to the <CODE>Value</CODE> hierarchy,
as shown in Figure&#XA0;<A HREF="#fig:scenevalue">46</A>.
We will also add dynamic type checks to the base class
to cover these cases.
This is shown in Figure&#XA0;<A HREF="#fig:scenecheck">47</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 46: Values<A NAME="fig:scenevalue"></A> for scene construction
(<TT>runtime.Value</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">import render.{Point, Light}

case class PointValue(point: Point) extends Value {
  override def toString = point.toString
}

case class LightValue(light: Light) extends Value {
  override def toString = light.toString
}

case class SceneValue(scene: Scene) extends Value {
  override def toString = scene.toString
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 47: Dynamic type checks<A NAME="fig:scenecheck"></A> for scene construction
(<TT>runtime.Value</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  def toPoint: Point = this match {
    case PointValue(p) =&gt; p
    case _ =&gt; typeError("Point")
  }

  def toLight: Light = this match {
    case LightValue(l) =&gt; l
    case _ =&gt; typeError("Light")
  }

  def toScene: Scene = this match {
    case SceneValue(s) =&gt; s
    case _ =&gt; typeError("Scene")
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>To implement the scene construction operators
it is useful to add some more lifting methods,
similar to those from section&#XA0;<A HREF="#sec:operators">3.6</A>.
These are shown in Figure&#XA0;<A HREF="#fig:liftscene">48</A>.
As before,
the letters at the end of the method names
stand for the types that the function argument expects.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 48: Lifting methods<A NAME="fig:liftscene"></A> for scene construction
(<TT>runtime.Operators</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  import render._

  def liftC(f: ClosureValue =&gt; Value)(data: DataStack): Unit =
    data.push(f(data.pop.toClosure))

  def liftP(f: Point =&gt; Value)(data: DataStack): Unit =
    data.push(f(data.pop.toPoint))

  def liftSS(f: (Scene, Scene) =&gt; Value)(data: DataStack): Unit = {
    val r = data.pop.toScene
    val l = data.pop.toScene
    data.push(f(l, r))
  }

  def liftSR(f: (Scene, Double) =&gt; Value)(data: DataStack): Unit = {
    val r = data.pop.toReal
    val s = data.pop.toScene
    data.push(f(s, r))
  }

  def liftPP(f: (Point, Point) =&gt; Value)(data: DataStack): Unit = {
    val p2 = data.pop.toPoint
    val p1 = data.pop.toPoint
    data.push(f(p1, p2))
  }

  def liftRRR(f: (Double, Double, Double) =&gt; Value)(data: DataStack): Unit = {
    val z = data.pop.toReal
    val y = data.pop.toReal
    val x = data.pop.toReal
    data.push(f(x, y, z))
  }

  def liftSRRR(f: (Scene, Double, Double, Double) =&gt; Value)
              (data: DataStack): Unit =
  {
    val z = data.pop.toReal
    val y = data.pop.toReal
    val x = data.pop.toReal
    val s = data.pop.toScene
    data.push(f(s, x, y, z))
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The operator implementations are shown in Figure&#XA0;<A HREF="#fig:sceneoptable">49</A>.
Most of the new operators simply construct a point, light or scene,
then wrap it in the appropriate <CODE>Value</CODE>.
We could have defined the spotlight operator using a lifting method as well,
but since there is only one operator with this signature
it is simpler to just define it in a private method.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 49: Operators<A NAME="fig:sceneoptable"></A> for scene construction
(<TT>runtime.Operators</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  val opTable: Map[String, OpType] = Map(
    ...
    "cone"       -&gt; liftC(s =&gt; SceneValue(Cone(s))),
    "cube"       -&gt; liftC(s =&gt; SceneValue(Cube(s))),
    "cylinder"   -&gt; liftC(s =&gt; SceneValue(Cylinder(s))),
    "difference" -&gt; liftSS((l, r) =&gt; SceneValue(Difference(l, r))),
    "getx"       -&gt; liftP(p =&gt; RealValue(p.x)),
    "gety"       -&gt; liftP(p =&gt; RealValue(p.y)),
    "getz"       -&gt; liftP(p =&gt; RealValue(p.z)),
    "intersect"  -&gt; liftSS((l, r) =&gt; SceneValue(Intersect(l, r))),
    "light"      -&gt; liftPP((d, c) =&gt; LightValue(PlainLight(d, c))),
    "plane"      -&gt; liftC(s =&gt; SceneValue(Plane(s))),
    "point"      -&gt; liftRRR((x, y, z) =&gt; PointValue(Point(x, y, z))),
    "pointlight" -&gt; liftPP((p, c) =&gt; LightValue(PointLight(p, c))),
    "rotatex"    -&gt; liftSR((s, d) =&gt; SceneValue(RotateX(s, d))),
    "rotatey"    -&gt; liftSR((s, d) =&gt; SceneValue(RotateY(s, d))),
    "rotatez"    -&gt; liftSR((s, d) =&gt; SceneValue(RotateZ(s, d))),
    "scale"      -&gt; liftSRRR((s, x, y, z) =&gt; SceneValue(Scale(s, x, y, z))),
    "sphere"     -&gt; liftC(s =&gt; SceneValue(Sphere(s))),
    "spotlight"  -&gt; doSpotLight,
    "translate"  -&gt; liftSRRR((s, x, y, z) =&gt; SceneValue(Translate(s, x, y, z))),
    "union"      -&gt; liftSS((l, r) =&gt; SceneValue(Union(l, r))),
    "uscale"     -&gt; liftSR((s, r) =&gt; SceneValue(UScale(s, r)))
  )

  private def doSpotLight(data: DataStack): Unit = {
    val exponent = data.pop.toReal
    val cutoff = data.pop.toReal
    val color = data.pop.toPoint
    val at = data.pop.toPoint
    val position = data.pop.toPoint
    data.push(LightValue(SpotLight(position, at, color, cutoff, exponent)))
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Transformations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc28">5.4</A>&#XA0;&#XA0;Transformations<A NAME="sec:transformations"></A></H3><!--SEC END --><P>Scenes are constructed by combining primitive shapes using set operations,
and applying <EM>affine</EM> transformations
to move the objects and change their shapes.
As discussed in the specification,
if we use <EM>homogeneous</EM> coordinates then
affine transformations become linear
and we can represent them using square matrices of real numbers.</P><P>The <CODE>Transform</CODE> class in Figure&#XA0;<A HREF="#fig:transform">50</A>
is used for the representation.
The top three rows of the matrix are listed off as parameters,
but since the bottom row consists of &#X201C;0 0 0 1&#X201D; for every transformation
there&#X2019;s no need to include parameters for these.
We use an immutable data structure because
later on we will need to multiply the same matrix
with two or more other matrices&#X2014;if the matrices were mutable we&#X2019;d have to think about
when the right time to copy would be,
and the problem is complex enough already without having to do that.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 50: The<A NAME="fig:transform"></A> <TT>Transform</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

// Represents a 4x4 matrix:
//    [x1 y1 z1 t1]
//    [x2 y2 z2 t2]
//    [x3 y3 z3 t3]
//    [ 0  0  0  1]
case class Transform(
          x1: Double, y1: Double, z1: Double, t1: Double,
          x2: Double, y2: Double, z2: Double, t2: Double,
          x3: Double, y3: Double, z3: Double, t3: Double
        )
{
  def transformRay(ray: Ray) =
    Ray(transformPoint(ray.origin), transformVector(ray.velocity))

  def transformPoint(p: Point) =
    Point(
      x1*p.x + y1*p.y + z1*p.z + t1,
      x2*p.x + y2*p.y + z2*p.z + t2,
      x3*p.x + y3*p.y + z3*p.z + t3
    )

  def transformVector(p: Point) =
    Point(
      x1*p.x + y1*p.y + z1*p.z,
      x2*p.x + y2*p.y + z2*p.z,
      x3*p.x + y3*p.y + z3*p.z
    )

  def *(m: Transform) =
    Transform(
      x1*m.x1 + y1*m.x2 + z1*m.x3,
      x1*m.y1 + y1*m.y2 + z1*m.y3,
      x1*m.z1 + y1*m.z2 + z1*m.z3,
      x1*m.t1 + y1*m.t2 + z1*m.t3 + t1,
      x2*m.x1 + y2*m.x2 + z2*m.x3,
      x2*m.y1 + y2*m.y2 + z2*m.y3,
      x2*m.z1 + y2*m.z2 + z2*m.z3,
      x2*m.t1 + y2*m.t2 + z2*m.t3 + t2,
      x3*m.x1 + y3*m.x2 + z3*m.x3,
      x3*m.y1 + y3*m.y2 + z3*m.y3,
      x3*m.z1 + y3*m.z2 + z3*m.z3,
      x3*m.t1 + y3*m.t2 + z3*m.t3 + t3
    )
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Matrix multiplication is defined in the usual way,
except with the zeros and ones substituted for the bottom row variables.
Obviously, we don&#X2019;t need to include the bottom row values
when we construct the result.</P><P>Transforming a point or vector is modeled by
multiplying the transformation vector on its left.
For points, the fourth coordinate is treated as one
and for vectors it is treated as zero.
In practice this means that a point will be moved by a translation,
but a vector will remain unchanged.
That is, a translation changes the position of something
but doesn&#X2019;t change its direction or speed.</P><P>The companion object in Figure&#XA0;<A HREF="#fig:transformobject">51</A>
contains methods for constructing primitive transformations,
including the identity representing the transformation that does nothing.
This is the identity matrix in four dimensions
(with its bottom row removed),
or equivalently can be thought of as the three dimensional identity,
which performs no rotation or scaling,
combined with a translation of zero.
The primitive transformation matrices are taken from the specification.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 51: The<A NAME="fig:transformobject"></A> <TT>Transform</TT> companion object.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">object Transform {
  val identity =
    Transform(1, 0, 0, 0,
              0, 1, 0, 0,
              0, 0, 1, 0)

  def rotationX(deg: Double): Transform = {
    val rad = Math.toRadians(deg)
    val sin = Math.sin(rad)
    val cos = Math.cos(rad)
    Transform(1, 0,    0,   0,
              0, cos, -sin, 0,
              0, sin,  cos, 0)
  }

  def rotationY(deg: Double): Transform = {
    val rad = Math.toRadians(deg)
    val sin = Math.sin(rad)
    val cos = Math.cos(rad)
    Transform(cos, 0, sin, 0,
              0,   1, 0,   0,
             -sin, 0, cos, 0)
  }

  def rotationZ(deg: Double): Transform = {
    val rad = Math.toRadians(deg)
    val sin = Math.sin(rad)
    val cos = Math.cos(rad)
    Transform(cos, -sin, 0, 0,
              sin,  cos, 0, 0,
              0,    0,   1, 0)
  }

  def translation(dx: Double, dy: Double, dz: Double) =
    Transform(1, 0, 0, dx,
              0, 1, 0, dy,
              0, 0, 1, dz)

  def dilation(rx: Double, ry: Double, rz: Double) =
    Transform(rx, 0, 0, 0,
              0, ry, 0, 0,
              0, 0, rz, 0)
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>When we do the ray tracing later on,
we shall be firing rays at transformed shapes
to determine the boundaries (if any)
where the ray enters or leaves a shape.
This is done by performing the inverse transformation on the ray,
then calculating the intersections with the shape in its original form.
We shall refer to the transformed shapes as being in <EM>world</EM> space,
and the originals as being in <EM>shape</EM> space.
The transformation goes from shape coordinates to world coordinates,
and the inverse goes from world coordinates to shape coordinates.</P><P>We will need to change coordinates in both directions,
so we will need a representation of
both the transformation matrix and its inverse.
Since we can easily calculate the inverse of
each of the primitive transformations,
we can build the transformation and its inverse at the same time.
This is more efficient than using an expensive matrix inversion procedure
to calculate the inverse after the transformation is fully built.</P><P>The <CODE>View</CODE> class, shown in Figure&#XA0;<A HREF="#fig:view">52</A>,
contains both the transformation matrix, called <CODE>s2w</CODE>,
and its inverse, called <CODE>w2s</CODE>.
The first six methods transform rays,
as well as the constituent points and vectors,
from shape to world coordinates and from world to shape coordinates.
Each of these methods delegates its implementation to the appropriate matrix.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 52: The<A NAME="fig:view"></A> <TT>View</TT> class and companion object.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import Transform._

case class View(s2w: Transform, w2s: Transform) {
  def rayToWorldSpace(ray: Ray) = s2w.transformRay(ray)
  def rayToShapeSpace(ray: Ray) = w2s.transformRay(ray)

  def pointToWorldSpace(p: Point) = s2w.transformPoint(p)
  def pointToShapeSpace(p: Point) = w2s.transformPoint(p)

  def vectorToWorldSpace(p: Point) = s2w.transformVector(p)
  def vectorToShapeSpace(p: Point) = w2s.transformVector(p)

  def rotateX(deg: Double) =
    View(s2w * rotationX(deg), rotationX(-deg) * w2s)

  def rotateY(deg: Double) =
    View(s2w * rotationY(deg), rotationY(-deg) * w2s)

  def rotateZ(deg: Double) =
    View(s2w * rotationZ(deg), rotationZ(-deg) * w2s)

  def translate(dx: Double, dy: Double, dz: Double) =
    View(s2w * translation(dx, dy, dz), translation(-dx, -dy, -dz) * w2s)

  def scale(rx: Double, ry: Double, rz: Double) =
    View(s2w * dilation(rx, ry, rz), dilation(1/rx, 1/ry, 1/rz) * w2s)

  def uScale(r: Double) = scale(r, r, r)
}

object View {
  val identity = View(Transform.identity, Transform.identity)
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The remaining methods add a primitive transformation to the view
and return a new view.
Each of these applies the corresponding transform to the matrix,
and the inverse transform to the inverse matrix,
using matrix multiplication.
For rotations, the inverse is found by negating the angle of rotation.
For translations, the inverse is found by negating each component.
For scaling, the inverse is found by taking the reciprocal of each component.
Isotropic scaling is simply defined in terms of regular scaling.</P><P>The identity is defined in a companion object.
It is easy to see that this satisfies an important requirement of transforms,
namely that the two matrices really are inverses,
because the identity transform is its own inverse.</P><P>It is useful for us to verify that
the requirement is also satisied for all transforms that we build.
Another way of stating the requirement is that
<CODE>s2w * w2s</CODE> must be equal to the identity
(modulo rounding errors).
Assume that this is true for view <CODE>v</CODE>,
and consider the view <CODE>v.rotateX(deg)</CODE>.
The requirement for this view amounts to
</P><DIV CLASS="center">
<CODE>v.s2w * rotationX(deg) * rotationX(-deg) * v.w2s</CODE>
</DIV><P>
being the identity.
The middle two terms clearly cancel out, leaving
</P><DIV CLASS="center">
<CODE>v.s2w * v.w2s</CODE>
</DIV><P>
which is the identity by our above assumption.
The same reasoning applies to all other methods of constructing views,
therefore they all satisfy the requirement.</P><P>This illustrates why the inverse is calculated by
multiplying on the left instead of on the right.
Matrix multiplication is not commutative,
so it is important that we get the order correct.
If we had defined <CODE>rotateX</CODE> with
</P><PRE CLASS="verbatim">  def rotateX(deg: Double) =
    View(s2w * rotationX(deg), w2s * rotationX(-deg))
</PRE><P>then the formula would be
</P><DIV CLASS="center">
<CODE>v.s2w * rotationX(deg) * v.w2s * rotationX(-deg)</CODE>
</DIV><P>
which would not in general be the identity.</P><!--TOC subsection Boundaries and boundary lists-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc29">5.5</A>&#XA0;&#XA0;Boundaries and boundary lists<A NAME="sec:boundaries"></A></H3><!--SEC END --><P>We will need to calculate the boundaries
where a ray enters or leaves a shape in the scene.
Ultimately, we will only be interested in
the first boundary after time zero that is an entry to a shape,
but because of the union, intersection and difference operations,
it is hard to know in advance which will be the first.
We thus keep all of the boundaries in a list,
and only choose the first entry after the final list is calculated.</P><P>Figure&#XA0;<A HREF="#fig:boundary">53</A> shows the <CODE>Boundary</CODE> class,
which holds information about the intersection of a ray and a shape,
and its companion object.
The information stored is the time of impact,
the point of impact in shape coordinates,
the shape itself and the number of the face that was hit.
The <CODE>Shape</CODE> type is defined in section&#XA0;<A HREF="#sec:shape">5.6.2</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 53: The<A NAME="fig:boundary"></A> <TT>Boundary</TT> class
and companion object.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

case class Boundary(time: Double, shapePoint: Point, shape: Shape, face: Int) {
  def &lt;(that: Boundary) = time &lt; that.time

  def worldPoint = shape.view.pointToWorldSpace(shapePoint)

  def faceCoordinates = shape.faceCoordinates(face, shapePoint)
}

object Boundary {
  type Boundaries = List[Boundary]
  
  def union(as: Boundaries, bs: Boundaries): Boundaries =
    (as, bs) match {
      case (Nil, _) =&gt; bs
      case (_, Nil) =&gt; as
      case (a :: as0, b :: bs0) =&gt;
        if (a &lt; b)      a :: difference(as0, bs)
        else if (b &lt; a) b :: difference(bs0, as)
        else            a :: intersect(as0, bs0)
    }

  def intersect(as: Boundaries, bs: Boundaries): Boundaries =
    (as, bs) match {
      case (Nil, _) =&gt; Nil
      case (_, Nil) =&gt; Nil
      case (a :: as0, b :: bs0) =&gt;
        if (a &lt; b)      difference(bs, as0)
        else if (b &lt; a) difference(as, bs0)
        else            a :: union(as0, bs0)
    }

  def difference(as: Boundaries, bs: Boundaries): Boundaries =
    (as, bs) match {
      case (Nil, _) =&gt; Nil
      case (_, Nil) =&gt; as
      case (a :: as0, b :: bs0) =&gt;
        if (a &lt; b)      a :: union(as0, bs)
        else if (b &lt; a) intersect(as, bs0)
        else            difference(bs0, as0)
    }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>A comparison operator is provided for boundaries.
This simply compares the impact times,
and is used heavily in the code below.
Even though we are defining comparison,
we don&#X2019;t make this extend the <CODE>Ordered</CODE> trait.
For that trait, the comparison operator must be
consistent with the definition of <CODE>equals</CODE>,
but this is not the case for our class
because boundaries at the same time may not necessarily be on the same shape.
So we just define the method without mentioning the trait,
and do without the rich interface it provides.</P><P>The <CODE>worldPoint</CODE> method simply returns
the <CODE>shapePoint</CODE> parameter in world coordinates.
The <CODE>faceCoordinates</CODE> method
returns the face coordinates of the surface point.
Both of these methods delegate their implementation to <CODE>Shape</CODE>.</P><P>The <CODE>Boundary</CODE> companion object provides
methods for working with lists of boundaries.
We keep the lists sorted in order of time,
and if there are eny boundaries at exactly the same time
we arbitrarily pick one of them.
This means that the boundaries in the list alternate between entries and exits.</P><P>The methods on boundary lists are
the union, intersect and difference operations of
a &#X201C;generalised Boolean algebra&#X201D;.
Each is defined by a case expression that matches the two list arguments.
The base cases, where one of the arguments is <CODE>Nil</CODE>,
can be easily understood if we interpret <CODE>Nil</CODE> as the empty set.
For example, the first case of <CODE>union</CODE> states that
the union of the empty set with any set <CODE>bs</CODE> is equal to <CODE>bs</CODE>.</P><P>The recursive cases can be understood if we interpret the head of a list
as being the set that starts at that entry point and goes on indefinitely,
except with the set represented by the tail removed.
Effectively, the list &#X201C;cons&#X201D; operator means
much the same thing as the difference operation,
but its first argument is a single entry rather than a list of boundaries.</P><P>Consider the <CODE>a &lt; b</CODE> case in the union operation.
The result has <CODE>a</CODE> as the first entry,
because this is the earliest entry into either set.
The tail of the list represents all the things that need to be removed
after the entry at <CODE>a</CODE>.
For the union operation,
this is <CODE>as0</CODE>, the holes from <CODE>as</CODE>,
minus everything in <CODE>bs</CODE>.
That is, the elements in <CODE>bs</CODE> are not holes anymore.</P><P>Since union is symmetric,
the case for <CODE>b &lt; a</CODE> is the same as above
except with the two arguments reversed.
In the remaining case we deal with the tails of both lists;
the holes in the result are those elements that are holes in both arguments.</P><P>A similar line of reasoning holds for the other two methods&#X2014;the cautious reader may wish to check this.
Two other things worth noting are that
the resulting lists are in order and have no duplicates,
as mentioned above,
and that the algorithm always terminates.
To see this last point,
note that one element is removed from the head of at least one of the lists
in each recursive case,
so we must run out of elements eventually.</P><!--TOC subsection The <TT>World</TT> class-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc30">5.6</A>&#XA0;&#XA0;The <TT>World</TT> class<A NAME="sec:world"></A></H3><!--SEC END --><P><CODE>World</CODE> is the abstract class used by the rendering engine
to represent shapes, their combinations and their transformations.
This section describes the class and its subclasses,
and gives a factory method for construction of worlds.</P><!--TOC subsubsection The base class and some subclasses-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc31">5.6.1</A>&#XA0;&#XA0;The base class and some subclasses<A NAME="sec:worldbase"></A></H4><!--SEC END --><P>The base class and some of the subclasses are shown in Figure&#XA0;<A HREF="#fig:world">54</A>.
The rendering engine uses the <CODE>World</CODE> for one purpose:
to find the boundaries crossed by a ray.
The <CODE>boundaries</CODE> abstract method takes a world-space ray as an argument
and returns the list of boundaries.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 54: The<A NAME="fig:world"></A> <TT>World</TT> base case and some subclasses.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import runtime._

abstract class World {
  // Return the list of boundaries where this world-space ray
  // crosses shapes in the world.
  def boundaries(ray: Ray): List[Boundary]
}

class Union(val left: World, val right: World) extends World {
  def boundaries(ray: Ray) =
    Boundary.union(left.boundaries(ray), right.boundaries(ray))
}

class Intersect(val left: World, val right: World) extends World {
  def boundaries(ray: Ray) =
    Boundary.intersect(left.boundaries(ray), right.boundaries(ray))
}

class Difference(val left: World, val right: World) extends World {
  def boundaries(ray: Ray) =
    Boundary.difference(left.boundaries(ray), right.boundaries(ray))
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>For the subclasses shown here,
<CODE>Union</CODE>, <CODE>Intersect</CODE> and <CODE>Difference</CODE>,
the boundaries are found by
getting the boundary lists for the left and right components,
then combining them with
the appropriate boundary list operation from the previous section.</P><!--TOC subsubsection The <TT>Shape</TT> subclass-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc32">5.6.2</A>&#XA0;&#XA0;The <TT>Shape</TT> subclass<A NAME="sec:shape"></A></H4><!--SEC END --><P>The <CODE>Shape</CODE> class,
shown with its companion object in Figure&#XA0;<A HREF="#fig:shape">55</A>,
is an abstract base class for shapes.
The first thing to notice is that there is a view parameter as well as
the closure value for the surface function.
This is what distinguishes these values from
the <CODE>Scene</CODE> values we built in section&#XA0;<A HREF="#sec:scene">5.3</A>.
These values include the complete transformations of the shapes,
whereas in scenes the transformation was determined by
the primitive transforms in the enclosing context.
The <CODE>World</CODE> class thus does not have any subclasses
to specifically represent the primitive transforms.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 55: The<A NAME="fig:shape"></A> <TT>Shape</TT> class and companion object.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import runtime.ClosureValue

abstract class Shape(val view: View, val surface: ClosureValue) extends World {
  def boundaries(ray: Ray) =
    shapeBoundaries(view.rayToShapeSpace(ray))

  // Same as boundaries, except the argument is in shape space.
  def shapeBoundaries(ray: Ray): List[Boundary]

  // Given a face and a surface point in shape coordinates, return
  // the unit normal in world coordinates.
  def normal(face: Int, surfacePoint: Point): Point = {
    val n = shapeNormal(face, surfacePoint)

    // Choose an independent vector.
    val q = if (n.x != 0 || n.y != 0) Point(0, 0, 1)
            else Point(1, 0, 0)

    // Find two perpendicular tangents in shape coordinates.
    val t1 = n cross q
    val t2 = n cross t1

    // Convert tangents to world space, which preserves their
    // tangent-hood but not their size.
    val w1 = view.vectorToWorldSpace(t1)
    val w2 = view.vectorToWorldSpace(t2)

    // Recover a unit normal in world space.
    (w1 cross w2).unit
  }

  // Given a face and a surface point in shape coordinates, return
  // a normal vector in shape coordinates.
  def shapeNormal(face: Int, surfacePoint: Point): Point

  // Convert a surface point in shape coordinates to face coordinates.
  def faceCoordinates(face: Int, surfacePoint: Point): (Double, Double)

  ...
}

object Shape {
  // Calculate angle in the range 0..1.
  def theta(y: Double, x: Double): Double = {
    val q = Math.atan2(y, x) / (2 * Math.Pi)
    if (q &gt; 0) q else q + 1
  }  
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Since it is easier to work in shape coordinates when dealing with a shape,
the implementation of <CODE>boundaries</CODE> converts the ray to shape-space
then calls <CODE>shapeBoundaries</CODE>, which is implemented in the subclasses.</P><P>Aside from finding the boundaries,
we will also need to calculate the surface normal vectors of the shape
(that is, vectors pointing perpendicularly out from the surface),
and find the face coordinates of a surface point.
The latter is left as an abstract method for the subclasses to implement.
For the former, we can easily calculate the normal in shape space,
but we have a problem because affine transformations don&#X2019;t preserve angles
so this won&#X2019;t generally be a normal in world space.</P><P>The <CODE>normal</CODE> method uses a couple of pieces of cleverness
to get around this problem.
First,
the cross product of any two independent (that is, non-parallel) vectors
is always at right angles to both of the vectors.
Second, while affine transformations don&#X2019;t preserve surface normals,
they do preserve tangents.
So we start by finding tangents to the shape-space normal,
defined abstractly,
by picking an independent vector and using the cross product operator twice.
When transformed to world space these will still be tangents,
so when we use the cross product operator once more
we get a vector at right angles to the tangents,
which is a surface normal in world space.
We return the unit of this vector.</P><P>The <CODE>Shape</CODE> companion object provides a method, <CODE>theta</CODE>,
which is from the specification.
It is used by several shapes to calculate their face coordinates.</P><P>The <CODE>Shape</CODE> class also defines some protected methods
for the subclasses to use when finding the boundaries.
These are shown in Figure&#XA0;<A HREF="#fig:shape2">56</A>.
The <CODE>bound</CODE> method provides a slightly shorter way of
constructing a boundary for the shape.
The <CODE>univ</CODE> method returns a boundary list with
just one entry at the origin of the ray and no exits.
We make sure this is intersected with our results,
so that we discard all boundaries with time less than zero.
The <CODE>unitDim</CODE> method intersects a boundary list with
the part of the ray where a chosen coordinate is between zero and one.
This is used to cut the ends off cones and cylinders,
and to form all of the sides of a cube.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 56: Support methods<A NAME="fig:shape2"></A> for shapes
(<TT>runtime.render.Shape</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  // Construct a boundary for the given ray in shape space, time and face.
  protected def bound(ray: Ray, time: Double, face: Int) =
    Boundary(time, ray(time), this, face)

  // Boundary list representing the whole ray.
  protected def univ(ray: Ray) =
    List(bound(ray, 0, 0))

  // Constrain one dimension by face0 at 0 and face1 at 1.
  protected def unitDim(list: List[Boundary], ray: Ray, origin: Double,
                  velocity: Double, face0: Int, face1: Int): List[Boundary] =
    if (list == Nil) Nil
    else if (velocity == 0) {
      if (origin &lt; 0 || origin &gt; 1) Nil
      else list
    } else {
      val bound0 = bound(ray, -origin / velocity, face0)
      val bound1 = bound(ray, (1 - origin) / velocity, face1)
      val list0 = if (velocity &lt; 0) {
        List(bound1, bound0)
      } else {
        List(bound0, bound1)
      }
      Boundary.intersect(list0, list)
    }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsubsection Quadratic roots-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc33">5.6.3</A>&#XA0;&#XA0;Quadratic roots<A NAME="sec:quadratic"></A></H4><!--SEC END --><P>We will need to solve quadratic formulas
to find the intersections with curved surfaces.
This is fairly standard textbook material,
so we won&#X2019;t go into it in detail.
The code is shown in Figure&#XA0;<A HREF="#fig:quadratic">57</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 57: The<A NAME="fig:quadratic"></A> <TT>Quadratic</TT> object.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

object Quadratic {
  sealed abstract class Roots
  case object NoRoots extends Roots
  case class OneRoot(root: Double) extends Roots
  case class DoubleRoot(root: Double) extends Roots
  case class TwoRoots(low: Double, high: Double) extends Roots

  // Return roots of a*t*t + 2*b*t + c.
  def solve(a: Double, b: Double, c: Double): Roots =
    if (a &lt; 0) solvePos(-a, -b, -c)
    else if (a &gt; 0) solvePos(a, b, c)
    else if (b != 0) OneRoot(-c / (2 * b))
    else NoRoots

  // As above but assumes a &gt; 0.  Method to reduce rounding error
  // adapted from "Numerical recipes".
  def solvePos(a: Double, b: Double, c: Double): Roots = {
    val dSqr = b*b - a*c
    if (dSqr &lt; 0) NoRoots
    else if (dSqr == 0) DoubleRoot(-b / a)
    else {
      val d = Math.sqrt(dSqr)
      if (b &lt; 0) {
        val q = d - b
        TwoRoots(c / q, q / a)
      } else if (b &gt; 0) {
        val q = -(d + b)
        TwoRoots(q / a, c / q)
      } else {
        val q = d / a
        TwoRoots(-q, q)
      }
    }
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The main thing to note is that we distinguish between the case where
there is a double root and where there is one root.
A double root comes about when
a ray just touches a curved surface but doesn&#X2019;t actually enter.
A single root comes about if the ray enters a curved surface but never leaves,
such as when a ray is parallel to the curved face of a cone.</P><!--TOC subsubsection Primitive shapes-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc34">5.6.4</A>&#XA0;&#XA0;Primitive shapes<A NAME="sec:shapes"></A></H4><!--SEC END --><P>Each of the primitive shapes is implemented as a subclass of <CODE>Shape</CODE>.
These subclasses need to provide the code
to return the boundaries of the shape on a ray,
the surface normal in shape coordinates at a point,
and the face coordinates of a surface point.</P><P>The <CODE>Sphere</CODE> class is shown in Figure&#XA0;<A HREF="#fig:sphere">58</A>.
To find the boundaries of a ray,
we need find the times where the distance from the origin is equal to one.
Equivalently,
the distance squared, given by <CODE>ray(time).squared</CODE>,
must be equal to one.
We set the quadratic coefficents appropriately and solve.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 58: The<A NAME="fig:sphere"></A> <TT>Sphere</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import runtime.ClosureValue

class Sphere(view: View, surface: ClosureValue) extends Shape(view, surface) {
  def shapeBoundaries(ray: Ray) = {
    // Solve ray(time).squared = 1.
    val a = ray.velocity.squared
    val b = ray.origin dot ray.velocity
    val c = ray.origin.squared - 1
    Quadratic.solve(a, b, c) match {
      case Quadratic.TwoRoots(low, high) =&gt;
        val list = List(bound(ray, low, 0), bound(ray, high, 0))
        Boundary.intersect(list, univ(ray))
      case _ =&gt; Nil
    }
  }

  def shapeNormal(face: Int, surfacePoint: Point) = surfacePoint

  def faceCoordinates(face: Int, surfacePoint: Point) =
    (Shape.theta(surfacePoint.x, surfacePoint.z), (surfacePoint.y + 1) / 2)
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>If there are two roots,
the line intersects the sphere and we need to create two boundaries,
one for each root.
We remove boundaries with time less than zero by
intersecting with <CODE>univ(ray)</CODE>.
If there are no roots,
the line does not intersect the sphere and the result is <CODE>Nil</CODE>.
If there is a double root,
it means that the line is a tangent to the sphere.
We treat this as not entering the sphere at all.</P><P>The case of one root can&#X2019;t arise for spheres,
because this only occurs if <CODE>a</CODE> is zero and <CODE>b</CODE> is nonzero.
For spheres, <CODE>a</CODE> can only be zero if the velocity of the ray is zero,
which doesn&#X2019;t make sense.
(Even if it did, <CODE>b</CODE> would also be zero,
so we wouldn&#X2019;t get a single root anyway.)</P><P>Calculating a surface normal is easy for spheres:
it has the same value as the surface point itself.
The formulas for face coordinates are taken from the specification,
for spheres and also for the other shapes below.</P><P>Figure&#XA0;<A HREF="#fig:cube">59</A> shows the <CODE>Cube</CODE> class.
To get the boundaries,
we start with the whole ray and call <CODE>unitDim</CODE> for each dimension,
passing the boundary list from one call to the next.
The result from the last call is returned.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 59: The<A NAME="fig:cube"></A> <TT>Cube</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import runtime.ClosureValue

class Cube(view: View, surface: ClosureValue) extends Shape(view, surface) {
  def shapeBoundaries(ray: Ray) = {
    var list = univ(ray)

    // faces 0, 1: z = 0, 1
    list = unitDim(list, ray, ray.origin.z, ray.velocity.z, 0, 1)

    // faces 2, 3: x = 0, 1
    list = unitDim(list, ray, ray.origin.x, ray.velocity.x, 2, 3)

    // faces 4, 5: y = 1, 0
    unitDim(list, ray, ray.origin.y, ray.velocity.y, 5, 4)
  }

  def shapeNormal(face: Int, surfacePoint: Point) = {
    object Normal {
      val faces: Array[Point] =
        Array(
          Point(0,  0, -1),
          Point(0,  0,  1),
          Point(-1, 0,  0),
          Point(1,  0,  0),
          Point(0,  1,  0),
          Point(0, -1,  0)
        )
    }
    Normal.faces(face)
  }

  def faceCoordinates(face: Int, surfacePoint: Point) = {
    val u = if (face == 2 || face == 3) surfacePoint.z else surfacePoint.x
    val v = if (face == 4 || face == 5) surfacePoint.z else surfacePoint.y
    (u, v)
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>There are only six distinct surface normals, one for each face.
We store an array of these normals, indexed by face,
in the <CODE>Normal</CODE> object inside the method.
The method itself just returns the corresponding entry in the array.</P><P>Figure&#XA0;<A HREF="#fig:cylinder">60</A> shows the cylinder class.
Finding the boundaries of the curved surface of cylinders is similar to
finding the boundaries of spheres,
except that we project everything onto the X-Z plane
(that is, we treat the Y-components of the origin and velocity as zero).
There is one more subtle difference in the case of no roots:
the ray might be <EM>inside</EM> the cylinder,
traveling parallel to it.
In this case, there will be no roots but the origin will be inside the
unit circle in the X-Z plane.
We can test for this by checking if <CODE>c</CODE> is less than zero.
If fully inside the cylinder, the result of this part is <CODE>univ(ray)</CODE>,
otherwise it is <CODE>Nil</CODE>.
Before returning the list,
the <CODE>unitDim</CODE> method is called to cut the ends off the cylinder.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 60: The<A NAME="fig:cylinder"></A> <TT>Cylinder</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import runtime.ClosureValue

class Cylinder(view: View, surface: ClosureValue) extends Shape(view, surface)
{
  def shapeBoundaries(ray: Ray) = {
    // Solve ray(time) dotXZ ray(time) = 1
    val a = ray.velocity dotXZ ray.velocity
    val b = ray.origin dotXZ ray.velocity
    val c = (ray.origin dotXZ ray.origin) - 1
    val list = Quadratic.solve(a, b, c) match {
      case Quadratic.TwoRoots(low, high) =&gt;
        val list0 = List(bound(ray, low, 0), bound(ray, high, 0))
        Boundary.intersect(list0, univ(ray))
      case Quadratic.NoRoots if (c &lt; 0) =&gt; univ(ray)
      case _ =&gt; Nil
    }
    // face 1, 2: y = 1, 0
    unitDim(list, ray, ray.origin.y, ray.velocity.y, 2, 1)
  }

  def shapeNormal(face: Int, surfacePoint: Point) =
    if (face == 1) Point(0, 1, 0)
    else if (face == 2) Point(0, -1, 0)
    else Point(surfacePoint.x, 0, surfacePoint.z)

  def faceCoordinates(face: Int, surfacePoint: Point) = {
    val u = if (face == 0) Shape.theta(surfacePoint.x, surfacePoint.z)
            else (surfacePoint.x + 1) / 2
    val v = if (face == 0) surfacePoint.y
            else (surfacePoint.z + 1) / 2
    (u, v)
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Faces 1 and 2, which are the two ends of the cylinder,
have constant surface normals.
For the curved face,
calculation of the surface normal is the same as for spheres
except projected onto the X-Z plane.</P><P>The <CODE>Cone</CODE> class is shown in Figure&#XA0;<A HREF="#fig:cone">61</A>.
Finding the boundaries involves solving similar equations as before,
except that the Y-terms are negated in the sums.
We do this with the <CODE>conjY</CODE> method on points.
These equations actually describe a double-sided cone,
which is shaped like an infinitely large hourglass.
The call to <CODE>unitDim</CODE> at the end of the method slices off
most of one side to produce the flat face of the cone,
and slices the other side off entirely.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 61: The<A NAME="fig:cone"></A> <TT>Cone</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import runtime.ClosureValue

class Cone(view: View, surface: ClosureValue) extends Shape(view, surface) {
  def shapeBoundaries(ray: Ray) = {
    // Solve ray(time) conjY ray(time) = 0
    val a = ray.velocity conjY ray.velocity
    val b = ray.origin conjY ray.velocity
    val c = ray.origin conjY ray.origin
    val list = Quadratic.solve(a, b, c) match {
      case Quadratic.NoRoots =&gt; Nil
      case Quadratic.OneRoot(root) =&gt;
        // Parallel to the cone.
        val list0 = List(bound(ray, root, 0))
        if (b &lt; 0) Boundary.intersect(univ(ray), list0) // entering the cone
        else Boundary.difference(univ(ray), list0)      // leaving the cone
      case Quadratic.DoubleRoot(root) =&gt;
        // Tangent to the cone.
        if (a &lt; 0) univ(ray)                            // inside the cone
        else Nil                                        // outside the cone
      case Quadratic.TwoRoots(low, high) =&gt;
        val list0 = List(bound(ray, low, 0), bound(ray, high, 0))
        if (a &gt; 0) Boundary.intersect(univ(ray), list0) // across the cone axis
        else Boundary.difference(univ(ray), list0)      // along the cone axis
    }
    // face 1: y = 1
    unitDim(list, ray, ray.origin.y, ray.velocity.y, 0, 1)
  }

  def shapeNormal(face: Int, surfacePoint: Point) =
    if (face == 1) Point(0, 1, 0)
    else Point(surfacePoint.x, -surfacePoint.y, surfacePoint.z)

  def faceCoordinates(face: Int, surfacePoint: Point) = {
    val u = if (face == 0) Shape.theta(surfacePoint.x, surfacePoint.z)
            else (surfacePoint.x + 1) / 2
    val v = if (face == 0) surfacePoint.y
            else (surfacePoint.z + 1) / 2
    (u, v)
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>If there are no roots, the cone is not intersected at all.</P><P>If there is one root, this means the ray is parallel to one side of the cone,
and the root is the location where the ray crosses
the other side of the cone.
We need to account for two cases:
one where we start outside the cone and enter at the root,
and the other where we start inside the cone and leave at the root.</P><P>If there is a double root,
the ray touches the cone at one location.
This could happen because the ray brushes the outside of the cone,
which we treat as being fully outside the cone,
or because the ray is fully inside the cone
and travels exactly through the tip where the two sides of the cone meet.</P><P>In the case of two roots, there are again two explanations.
The ray could be traveling <EM>across</EM> the axis of the cone,
in which case it starts outside the cone,
enters on one side,
then leaves while still on the same side.
Alternatively,
the ray could be traveling <EM>along</EM> the axis of the cone,
in which case it starts inside one side of the cone,
leaves the cone in the middle,
then enters again on the other side.</P><P>The surface normal is constant for face 1,
and for face 0 is found by negating the Y-component of the surface point.</P><P>The last primitive shape class is <CODE>Plane</CODE>,
shown in Figure&#XA0;<A HREF="#fig:plane">62</A>.
For the boundaries,
we first need to check whether the ray is parallel to the plane,
in which case it is either fully in or fully out,
depending on the Y-component of the origin.
Otherwise,
we find the boundary by solving a linear equation,
and determine whether we are travelling into or out of the plane
by looking at the Y-component of the velocity.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 62: The<A NAME="fig:plane"></A> <TT>Plane</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import runtime.ClosureValue

class Plane(view: View, surface: ClosureValue) extends Shape(view, surface) {
  def shapeBoundaries(ray: Ray) =
    if (ray.velocity.y == 0) {
      if (ray.origin.y &gt;= 0) Nil
      else univ(ray)
    } else {
      val list0 = List(bound(ray, -ray.origin.y / ray.velocity.y, 0))
      if (ray.velocity.y &lt; 0) Boundary.intersect(univ(ray), list0)
      else Boundary.difference(univ(ray), list0)
    }

  def shapeNormal(face: Int, surfacePoint: Point) = Point(0, 1, 0)

  def faceCoordinates(face: Int, surfacePoint: Point) =
    (surfacePoint.x, surfacePoint.z)
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The surface normal of a plane is constant at every point,
and the face coordinates are just the X and Z coordinates of the surface point.</P><!--TOC subsubsection The <TT>World</TT> factory.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc35">5.6.5</A>&#XA0;&#XA0;The <TT>World</TT> factory.<A NAME="sec:worldfactory"></A></H4><!--SEC END --><P>The <CODE>World</CODE> companion object,
shown in Figure&#XA0;<A HREF="#fig:worldobject">63</A>,
contains a factory method for
creating a world out of a scene and an initial view.
Before we start rendering,
we will call this method with the scene to be rendered
and the identity view.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 63: The<A NAME="fig:worldobject"></A> <TT>World</TT> companion object.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">object World {
  def make(view: View, scene: Scene): World =
    scene match {
      case Sphere(surface)   =&gt; new Sphere(view, surface)
      case Cube(surface)     =&gt; new Cube(view, surface)
      case Cylinder(surface) =&gt; new Cylinder(view, surface)
      case Cone(surface)     =&gt; new Cone(view, surface)
      case Plane(surface)    =&gt; new Plane(view, surface)

      case Union(left, right) =&gt;
        new Union(make(view, left), make(view, right))
      case Intersect(left, right) =&gt;
        new Intersect(make(view, left), make(view, right))
      case Difference(left, right) =&gt;
        new Difference(make(view, left), make(view, right))

      case RotateX(scene0, degrees) =&gt; make(view.rotateX(degrees), scene0)
      case RotateY(scene0, degrees) =&gt; make(view.rotateY(degrees), scene0)
      case RotateZ(scene0, degrees) =&gt; make(view.rotateZ(degrees), scene0)
      case Translate(scene0, dx, dy, dz) =&gt;
        make(view.translate(dx, dy, dz), scene0)
      case Scale(scene0, rx, ry, rz) =&gt; make(view.scale(rx, ry, rz), scene0)
      case UScale(scene0, r)         =&gt; make(view.uScale(r), scene0)
    }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>For primitive shapes,
we create new instances of the appropriate shape class.
For the Boolean operations,
we recursively make the worlds for the two parameters
then combine them as the appropriate type of world.
The same view is passed unchanged to the recursive calls.
For the transformations,
we recursively make the world for the parameter,
but with a view that has been appropriately modified.</P><P>The reason we use a separate representation of scenes and worlds is efficiency.
We do all of the matrix multiplications in one place,
so that we minimize the amount of work to be done.
If the matrix multiplications were done during ray tracing,
the same computations would effectively be repeated thousands of times
which is an enormous and unnecessary cost.
On the other hand,
if they were done during scene construction
we would need to apply <EM>each</EM> transformation to all shapes separately,
instead of collapsing all the transformations for a shape into one
before applying it.
This probably isn&#X2019;t as bad as the first case,
but may still be a significant problem.</P><!--TOC subsection Surface properties-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">5.7</A>&#XA0;&#XA0;Surface properties<A NAME="sec:properties"></A></H3><!--SEC END --><P>The surface of a shape is defined by a surface function,
which is a closure value
that pops the face number and coordinates off the data stack
and pushes the surface properties.
To find the surface properties we need to
call the virtual machine recursively to execute the function&#X2014;it is recursive because it is called when
the virtual machine is running
a GML program for which it has reached a <CODE>render</CODE> operator
(more on this later).</P><P>The <CODE>Properties</CODE> class represents surface properties.
It is shown in Figure&#XA0;<A HREF="#fig:properties">64</A> with its companion object.
The <CODE>surfaceProperties</CODE> method in the companion object 
performs the call to the surface function
and returns the result in a <CODE>Properties</CODE> value.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 64: The<A NAME="fig:properties"></A> <TT>Properties</TT> class
and companion object.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

import render.Point

case class Properties(color: Point, kd: Double, ks: Double, exp: Double)

object Properties {
  def properties(vm: VM, surface: ClosureValue, face: Int,
                 u: Double, v: Double): Properties =
  {
    // Save registers.
    val savedContext = vm.currentContext
    val savedCodePointer = vm.codePointer
    val savedReturnPointer = vm.returnPointer

    // Perform call.
    vm.data.push(IntValue(face))
    vm.data.push(RealValue(u))
    vm.data.push(RealValue(v))
    vm.currentContext = surface.context
    vm.execute(surface.address)
    val exp = vm.data.pop.toReal
    val ks = vm.data.pop.toReal
    val kd = vm.data.pop.toReal
    val color = vm.data.pop.toPoint

    // Restore registers.
    vm.returnPointer = savedReturnPointer
    vm.codePointer = savedCodePointer
    vm.currentContext = savedContext

    // Return the properties.
    Properties(color, kd, ks, exp)
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Since the virtual machine is already running,
we need to save the registers before the call and restore them afterwards,
otherwise it will get confused when it tries to resume
after processing the <CODE>render</CODE> operator.
Doing the call involves pushing the three inputs,
then setting the closure context and executing the address,
then popping the outputs in reverse order.
At the end, the outputs are
packaged in a <CODE>Properties</CODE> value and returned.</P><!--TOC subsection Dealing with surface acne-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc37">5.8</A>&#XA0;&#XA0;Dealing with surface acne<A NAME="sec:acne"></A></H3><!--SEC END --><P>We have to be careful when dealing with shape boundaries,
because of the so-called <EM>surface acne</EM> problem
that can result from rounding errors.
When a ray hits a shape,
we need to fire several rays from the point of intersection
to determine how the point is illuminated.
If, due to rounding errors,
the intersection point ends up slightly inside the shape,
the secondary rays will immediately hit the boundary of the shape
even though they shouldn&#X2019;t be affected by it.</P><P>Because of the way we have constructed our boundary lists,
any time this rounding problem happens
there will be <EM>two</EM> bogus boundaries at the start of the list.
One will be the boundary described above,
but before that there will be a boundary at time zero,
which is left over from intersecting with the <CODE>univ(ray)</CODE> value
(section&#XA0;<A HREF="#sec:shapes">5.6.4</A>).</P><P>Any time there is a boundary at time zero,
it means the origin of the ray was inside a solid shape.
Since rays should never get inside solid things to begin with,
we know this must be due to a rounding error
and we ignore the first pair of boundaries.<SUP><A NAME="text5" HREF="#note5">5</A></SUP></P><P>The method in Figure&#XA0;<A HREF="#fig:firstentry">65</A> performs this step.
It is a member of the <CODE>Boundary</CODE> companion object.
Using this method, we avoid the problem of surface acne
without affecting any other part of the image.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 65: The<A NAME="fig:firstentry"></A> <TT>firstEntry</TT> method
(<TT>runtime.render.Boundary</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  def firstEntry(as: Boundaries): Option[Boundary] =
    as match {
      case a :: _ if (a.time &gt; 0) =&gt; Some(a)
      case _ :: _ :: a :: _ =&gt; Some(a)
      case _ =&gt; None
    }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection Ray tracing-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc38">5.9</A>&#XA0;&#XA0;Ray tracing<A NAME="sec:raytracing"></A></H3><!--SEC END --><P>The main rendering loop and the ray tracing itself will be
performed by the <CODE>Render</CODE> class.
The start of this class is shown in Figure&#XA0;<A HREF="#fig:render">66</A>.
The parameters consist of a virtual machine,
plus some of the inputs to the render operator.
The remaining inputs will be provided to the rendering method,
defined later in section&#XA0;<A HREF="#sec:render">5.11</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 66: The<A NAME="fig:render"></A> <TT>Render</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import runtime._

class Render(vm: VM,
             world: World,
             ambient: Point,
             lights: Array[Light],
             maxDepth: Int)
{
  // What is the color if there is no object hit?
  val background = Point(0, 0, 0)

  // Don't consider color components less than this value.
  val cutoff = 0.001

  // Return the square of the distance to the nearest entry, or None
  // if there is no such boundary.
  def fireShadowRay(ray: Ray): Option[Double] =
    Boundary.firstEntry(world.boundaries(ray)) map
            { b =&gt; (b.worldPoint - ray.origin).squared }

  ...
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>It defines two constant values,
for the background color and for the minimum color value to consider.
When firing rays,
if the result is going to be multiplied by a number less than
the minimum color value,
then we don&#X2019;t bother firing the ray at all and just return black.</P><P>The <CODE>fireShadowRay</CODE> method is used to determine if the light
from a particular source reaches a given point
without being blocked by another shape.
If there are no boundaries on the ray then the light will definitely reach;
we return <CODE>None</CODE> to indicate this result.
If there is a boundary then we return its distance squared.
This will be passed to the <CODE>Light.isBlocked</CODE> method
from section&#XA0;<A HREF="#sec:lights">5.2</A>.</P><P>Before we implement the main ray tracing method,
it is helpful to create a class that captures the illumination model.
The <CODE>Illumination</CODE> class in Figure&#XA0;<A HREF="#fig:illumination">67</A>
represents the illumination of a boundary point on a ray.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 67: The<A NAME="fig:illumination"></A> <TT>Illumination</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime.render

import Math.{abs, pow}
import runtime.Properties

class Illumination(render: Render,
                   ray: Ray,
                   boundary: Boundary,
                   properties: Properties)
{
  val black = Point(0, 0, 0)
  val point = boundary.worldPoint
  val normal = boundary.shape.normal(boundary.face, boundary.shapePoint)
  val velocityDotNormal = ray.velocity dot normal
  val reflection = Ray(point, ray.velocity - (normal * velocityDotNormal * 2))

  // Illumination at this point from a given light.
  def fromLight(light: Light): Point = {
    val shadowRay = Ray(point, light.directionFrom(point))
    if (velocityDotNormal * (shadowRay.velocity dot normal) &gt;= 0) {
      // The light source is below the horizon.
      return black
    }

    val attenuation = light.attenuation(shadowRay)
    if (attenuation &lt; render.cutoff) {
      // There is not enough light to bother.
      return black
    }

    render.fireShadowRay(shadowRay) match {
      case Some(dSqr) if (light.isBlocked(point, dSqr)) =&gt;
        // The light is blocked by something.
        return black
      case _ =&gt;
    }

    val halfway = (shadowRay.velocity - ray.velocity).unit
    val specular = pow(abs(normal dot halfway), properties.exp) * properties.ks
    val diffuse = abs(normal dot shadowRay.velocity) * properties.kd
    light.color * (specular + diffuse) * attenuation
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The first part of the class defines several values based on
the class parameters.
These same values will be used for the specular reflection
and the contribution of each light in the scene,
so it makes sense to calculate them once for the chosen boundary
rather than repeat the calculations multiple times.</P><P>The <CODE>fromLight</CODE> method returns the contribution,
specular and diffuse,
of a light at the boundary point.
The first step is to work out the shadow ray for this light.
That is, the unit ray that points towards the light from the boundary.
Before doing the rest of the calculation we perform three checks
to determine whether there should be any contribution at all.</P><P>We first check that the light is above the horizon.
That is, the boundary point cannot be in the shadow of the object itself.
This is slightly tricky because we don&#X2019;t know whether the normal
points inside or outside the surface,
but if the incoming velocity vector
is on the same side of the surface as the normal,
then the shadow velocity vector must be on the opposite side.
In other words,
the dot product of the incoming velocity and the normal
must have the opposite sign to
the dot product of the shadow velocity and the normal.
Equivalently,
the (real) product of these two dot products must be negative,
so this is what we check for.</P><P>The second check is that the attenuation we calculate is not below the cutoff.
Since the end result will be multiplied by the attenuation,
if the value is close to zero we might as well return black
without performing the rest of the computation.</P><P>The last check is done after firing the shadow ray.
Here we just check that there is nothing blocking the light.</P><P>When calculating the contributions,
we again need to account for the fact that the normal vector
may be pointing inside the object.
The effect would be that the dot products of the normal with
the <CODE>halfway</CODE> vector and with the shadow vector
would have the wrong sign.
Since we know that both the incident ray and the shadow ray
are above the horizon,
we know these dot products must be positive,
therefore we just take the absolute value.</P><P>The main ray tracing method is shown in Figure&#XA0;<A HREF="#fig:fireray">68</A>.
We first check the depth limit;
if the limit is reached we must stop now and return the background color.
We then try to find the first entry,
and return the background color of none is found.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 68: The<A NAME="fig:fireray"></A> <TT>fireRay</TT> method
(<TT>runtime.render.Render</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  // Return the color seen in the direction of this ray,
  // assuming we are at the given recursion depth.
  def fireRay(ray: Ray, depth: Int): Point =
    if (depth &gt; maxDepth) background
    else Boundary.firstEntry(world.boundaries(ray)) match {
      case None =&gt; background
      case Some(boundary) =&gt;
        val (u, v) = boundary.faceCoordinates
        val properties = Properties.properties(vm, boundary.shape.surface,
                                               boundary.face, u, v)
        val illumination = new Illumination(this, ray, boundary, properties)
        val ambientReflection = ambient * properties.kd
        val specularReflection =
          if (properties.ks * properties.color.maxCoordinate &lt; cutoff) {
            background
          } else {
            fireRay(illumination.reflection, depth + 1) * properties.ks
          }
        var lighting = ambientReflection + specularReflection
        for (light &lt;- lights) lighting += illumination.fromLight(light)
        lighting times properties.color
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Having chosen our boundary,
we evaluate the surface properties and create an illumination instance.
We calculate the light from ambient and specular reflection,
but before making the recursive call for specular reflection,
we check whether the result would be significant.
We don&#X2019;t make the call if the maximum possible coordinate value of the color
is below the cutoff.</P><P>We then add up the various components in the illumination model,
accumulating them in the <CODE>lighting</CODE> variable.
The final result is the sum of the lighting components
times the color of the surface at that point.</P><!--TOC subsection Pixmaps-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc39">5.10</A>&#XA0;&#XA0;Pixmaps<A NAME="sec:pixmap"></A></H3><!--SEC END --><P>The output of the program is in the form of a &#X201C;Portable Pixmap File&#X201D;.
Before we get to the rendering loop,
we need to write code that writes the pixel colors
to a file in this format.</P><P>Figure&#XA0;<A HREF="#fig:pixmap">69</A> shows the <CODE>Pixmap</CODE> class,
which stores the array of pixels while we are rendering the image
then outputs the file when we are finished.
The <CODE>update</CODE> method is called to set a pixel value,
or the equivalent assignment syntax is used.
The <CODE>output</CODE> method opens a file with the given name,
writes the header and pixel values,
then closes the file.
The pixel values are converted to the appropriate range before being written.</P><P>The pixels are stored in an array of arrays.
When the outer array is created we need to create all the inner arrays as well,
otherwise when <CODE>update</CODE> is called a null value will be dereferenced.
The two-argument constructor performs this creation for arrays of arrays.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 69: The<A NAME="fig:pixmap"></A> <TT>Pixmap</TT> class.</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">package runtime

import render.Point
import java.io.{BufferedOutputStream, FileOutputStream}

class Pixmap(width: Int, height: Int) {
  val header = "P6 "+ width +" "+ height +" 255\n"

  val pixels = new Array[Array[Point]](height, width)

  def update(x: Int, y: Int, color: Point): Unit = {
    pixels(y)(x) = color
  }

  def output(filename: String): Unit = {
    val s = new BufferedOutputStream(new FileOutputStream(filename))
    s.write(header.getBytes)
    for (row &lt;- pixels; pixel &lt;- row) {
      s.write(colorVal(pixel.x))
      s.write(colorVal(pixel.y))
      s.write(colorVal(pixel.z))
    }
    s.close
  }

  // Convert from 0..1 to 0..255.
  def colorVal(v: Double): Int = {
    val scaled = v * 256
    if (scaled &lt; 0) 0
    else if (scaled &gt; 255) 255
    else scaled.toInt
  }
}
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><!--TOC subsection The <TT>render</TT> operator-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc40">5.11</A>&#XA0;&#XA0;The <TT>render</TT> operator<A NAME="sec:render"></A></H3><!--SEC END --><P>The render operator will need to start the main rendering loop,
which iterates over all of the pixels in the target image and fires the rays.
The rendering loop implementation is
in method <CODE>render</CODE> in class <CODE>Render</CODE>,
shown in Figure&#XA0;<A HREF="#fig:renderloop">70</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 70: The<A NAME="fig:renderloop"></A> rendering loop
(<TT>runtime.render.Render</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  import Math.{tan, toRadians}

  // Render the image.
  def render(fieldOfView: Double, width: Int, height: Int, filename: String) = {
    val imageWidth = 2 * tan(0.5 * toRadians(fieldOfView))
    val pixelSize = imageWidth / width
    val imageHeight = pixelSize * height
    val imageLeft = -imageWidth / 2
    val imageTop = imageHeight / 2
    val origin = Point(0, 0, -1)
    val pixmap = new Pixmap(width, height)

    // Main loop.
    for (j &lt;- 0 until height) {
      for (i &lt;- 0 until width) {
        val x = imageLeft + (i + 0.5) * pixelSize
        val y = imageTop - (j + 0.5) * pixelSize
        val ray = Ray(origin, Point(x, y, 1).unit)
        pixmap(i, j) = fireRay(ray, 1)
      }
      if (j % 8 == 7) print(".")
    }
    println("")

    // output
    pixmap.output(filename)
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The method first evaluates some constants
for use in calculating the ray direction,
then creates a <CODE>Pixmap</CODE> to store the results.
The loop itself calls <CODE>fireRay</CODE>,
with an initial depth of 1,
on each iteration.
We print a &#X201C;.&#X201D; every eighth row of pixels,
so on large examples the user isn&#X2019;t left with
a long and mystifying wait before receiving any feedback.
We also print a newline after the loop to get all the dots out of the way.</P><P>Finally, the method calls the <CODE>output</CODE> method of the pixmap
to write the file.</P><P>We can now give the definition of the <CODE>render</CODE> method
in class <CODE>VM</CODE>,
which implements the GML render operator.
The code is shown in Figure&#XA0;<A HREF="#fig:renderop">71</A>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 71: The<A NAME="fig:renderop"></A> render operator (<TT>runtime.VM</TT>).</TD></TR>
</TABLE></DIV><FONT COLOR="blue">
</FONT><PRE CLASS="verbatim"><FONT COLOR="blue">  import render.{Render, World, View}

  private def render: Unit = {
    val filename = data.pop.toStr
    val height = data.pop.toInt
    val width = data.pop.toInt
    val fieldOfView = data.pop.toReal
    val depth = data.pop.toInt
    val world = World.make(View.identity, data.pop.toScene)
    val lights = data.pop.toArray map { _ toLight }
    val ambient = data.pop.toPoint
    new Render(this, world, ambient, lights, depth).
            render(fieldOfView, width, height, filename)
  }
</FONT></PRE><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The inputs to the operator are first read, in reverse order.
The scene value must be converted to a <CODE>World</CODE>,
using the <CODE>make</CODE> factory method.
The identity view is passed in to start the process off.
Since the <CODE>toArray</CODE> method just returns
an array of values,
we need to convert the lights value to an array of lights
using a map expression.</P><P>After the inputs are read,
we create a new instance of <CODE>Render</CODE>
and call the method defined above.</P><P>This is the final piece of code for our program.
We can now run examples using all of the scene building
and rendering functionality of GML.</P><!--BEGIN NOTES section-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note4" HREF="#text4">4</A></DT><DD CLASS="dd-thefootnotes">Since the scene being rendered is not moving,
it doesn&#X2019;t matter that the rays have a speed as well as a direction.
We treat the rays as having a velocity rather than just a direction,
because it simplifies our calculations later on.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note5" HREF="#text5">5</A></DT><DD CLASS="dd-thefootnotes">Actually, this isn&#X2019;t quite right.
It can also happen if the observer
is stuck inside a solid object in the scene.
The specification doesn&#X2019;t say what to do in such an unfortunate case,
but our program at least lets the doomed observer
see out of their prison,
even if nobody else can see them.
</DD></DL>
<!--END NOTES-->
<!--TOC section Exercises for the reader-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc41">6</A>&#XA0;&#XA0;Exercises<A NAME="sec:exercises"></A> for the reader</H2><!--SEC END --><!--NAME exercises.html-->
<P>There are probably quite a few ways in which our program can be improved.
Any bugs that I am aware of have been fixed,
although that&#X2019;s not to say there aren&#X2019;t any others.
Kind and/or useful bug reports will be warmly received, of course,
and patches even more so.</P><P>Some potential improvements are collected here as challenge exercises.
Readers who would like to try Scala out for themselves
may wish to give one or more of them a go.</P><P>
<B>Exercise 1</B><BR>
Add an operator <CODE>string</CODE> that converts any integer
to a string containing its decimal representation.
Add an operator <CODE>append</CODE> that appends two strings
to form another string.
These operators can be used for building a filename inside a function
that may be called more than once
(for example, to produce an animation
consisting of a sequence of still images).
</P><P>
<B>Exercise 2</B><BR>
Extend the lexer to allow a <CODE>#include</CODE> directive
that reads tokens from the included file until the end,
then continues reading tokens from after the directive.
Recursive includes should also be handled correctly.
If a cycle is detected
(that is, we reach an include directive for a file that is already being read)
the included file should be skipped.
Optionally provide a compiler warning when this happens.
</P><P>
<B>Exercise 3</B><BR>
Change
the definition of the <CODE>Op</CODE> class from section&#XA0;<A HREF="#sec:bytecode">3.3</A>
as follows:
</P><PRE CLASS="verbatim">case class Op(index: Int) extends Bytecode
</PRE><P>The <CODE>index</CODE> parameter is an index into an operator table.
Modify the compiler to keep track of the operator index,
rather than the operator implementation as it currently does.
To execute the bytecode,
the virtual machine should look up the implementation in the operator table
and run it.</P><P>What advantages and/or disadvantages
does this design change have for our virtual machine?
</P><P>
<B>Exercise 4</B><BR>
Error handling by the <CODE>Main</CODE> object is not very sophisticated.
For example,
out-of-bounds errors for arrays are not printed in a meaningful way.
Aside from the type errors that we already report,
try to figure out the possible ways a well-formed GML program
could cause an exception to be thrown by the virtual machine at runtime.
Add code to catch these exceptions
and provide the user with some constructive feedback on the error.
</P><P>
<B>Exercise 5</B><BR>
Add add integer parameter to the <CODE>Term</CODE> base class to hold
the line number of the first character in the term.
During code generation,
create an array of integers parallel to the bytecode array,
with each integer being the line number of
the term which caused that bytecode to be generated.
When a runtime error occurs,
the point of execution can be determined
from the current value of the code pointer register.
Use the information in the array to report the line number
of the term that was executing,
along with the error message.
</P><P>
<B>Exercise 6</B><BR>
Add a transformation operator <CODE>bound</CODE> that
doesn&#X2019;t change the appearance of the scene at all,
but causes a bounding-sphere calculation to be performed.
When converting the scene into a world at the start of rendering,
a sphere (that is, a center point and radius)
that encloses that part of the scene should be found.
The sphere <EM>must not</EM> cut off any part of the scene,
and ideally it should be as small as possible.
</P><P>When firing a ray at this scene,
a quick check should first be performed
to see whether the ray intersects the bounding sphere.
If there is no intersection,
then there will be no boundaries with the scene inside the sphere
and the expensive boundary calculation doesn&#X2019;t need to be performed.
If there is an intersection then the boundaries should be calculated as before.</P><P>
<B>Exercise 7</B><BR>
Add a preprocessing stage to rendering
that tries to find good places
to automatically add bounding sphere calculations.
Better results may be possible if the
unions, intersections and differences are rearranged
so as to cluster primitive shapes together.
This should be done in accordance with the laws of Boolean algebra,
to ensure that the image is never affected by the optimisations.
Choose a set of benchmarks and try to measure a performance improvement.
</P><P>
<B>Exercise 8</B><BR>
Consider the following slightly contrived GML code:
</P><DIV CLASS="center">
<CODE>42 /x {{{ ... {{{x}}} ... }}} apply ... apply</CODE>
</DIV><P>
Each of the nested closures has <CODE>x</CODE> as a nonlocal;
each constructs another closure using <CODE>x</CODE> then returns,
until the innermost one which pushes the value 42.
All this constructing of contexts for the nonlocal <CODE>x</CODE>
is somewhat unnecessary,
since <CODE>x</CODE> is bound at the top level
and therefore has the constant value 42 wherever it is used.
It is effectively a global constant.
The bytecode could equivalently just push the literal value
and not use the context at all.
</P><P>Implement a compiler analysis pass that searches for opportunities
to use global constants instead of nonlocal context slots.
Hint: in Figure&#XA0;<A HREF="#fig:compiler">38</A> all of the analysis passes are called
<EM>after</EM> the call to <CODE>recursiveCompile</CODE>.
In what circumstances would you want a compiler pass to be called before
the recursive call?</P><P>
<B>Exercise 9</B><BR>
If a literal value, or a global constant from the previous exercise,
is pushed immediately before an operator such as <CODE>sin</CODE> or <CODE>cos</CODE>,
the operation can be performed once at compile time
and the resulting value substituted into the bytecode.
Implement this compiler optimization,
and any other extensions to this idea that you can think of.
</P><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
